
This document contains Gmail API-specific authorization and
authentication information. Before reading this document, be sure to read the
Google Workspace's general authentication and authorization information at
Learn about authentication and authorization.
Configure OAuth 2.0 for authorization
Configure the OAuth consent screen and choose scopes
to define what information is displayed to users and app reviewers, and register
your app so that you can publish it later.
Gmail API scopes
To define the level of access granted to your app, you need to identify and
declare authorization scopes. An authorization scope is an OAuth 2.0 URI string
that contains the Google Workspace app name, what kind of data it accesses, and
the level of access. Scopes are your app's requests to work with Google Workspace data, including
  users' Google Account data.
When your app is installed, a user is asked to validate the scopes used
by the app. Generally, you should choose the most narrowly focused scope
possible and avoid requesting scopes that your app doesn't require. Users more
readily grant access to limited, clearly described scopes.
If your public application uses scopes that permit access to
  certain user data, it must complete a verification process. If you see unverified
  app on the screen when testing your application, you must submit a
  verification request to remove it. Find out more about
  unverified apps
  and get answers to 
  frequently asked questions about app verification in the Help Center.

The Gmail API supports the following scopes:


Scope code
Description
Usage


https://www.googleapis.com/auth/gmail.addons.current.action.compose
Manage drafts and send emails when you interact with the
add-on.
Non-sensitive


https://www.googleapis.com/auth/gmail.addons.current.message.action
View your email messages when you interact with the
add-on.
Non-sensitive


https://www.googleapis.com/auth/gmail.addons.current.message.metadata
View your email message metadata when the add-on
is running.
Sensitive


https://www.googleapis.com/auth/gmail.addons.current.message.readonly
View your email messages when the add-on is
running.
Sensitive


https://www.googleapis.com/auth/gmail.labels
Create, read, update, and delete labels only.
Non-sensitive


https://www.googleapis.com/auth/gmail.send
Send messages only. No read or modify privileges on mailbox.
Sensitive


https://www.googleapis.com/auth/gmail.readonly
Read all resources and their metadata—no write operations.
Restricted


https://www.googleapis.com/auth/gmail.compose
Create, read, update, and delete drafts. Send messages and drafts.
Restricted


https://www.googleapis.com/auth/gmail.insert
Insert and import messages only.
Restricted


https://www.googleapis.com/auth/gmail.modify
All read/write operations except immediate, permanent deletion of
  threads and messages, bypassing Trash.
Restricted


https://www.googleapis.com/auth/gmail.metadata
Read resources metadata including labels, history records, and email
  message headers, but not the message body or attachments.
Restricted


https://www.googleapis.com/auth/gmail.settings.basic
Manage basic mail settings.
Restricted


https://www.googleapis.com/auth/gmail.settings.sharing

Manage sensitive mail settings, including forwarding rules and aliases.


Note:Operations guarded by this scope are restricted to
administrative use only. They are only available to Google Workspace customers
using a service account with domain-wide delegation.

Restricted


https://mail.google.com/
Full access to the account's mailboxes, including permanent deletion of
    threads and messages This scope should only be requested if your application
    needs to immediately and permanently delete threads and messages, bypassing
    Trash; all other actions can be performed with less permissive scopes.
Restricted


The Usage column in the table above indicates the sensitivity of each scope,
according to the following definitions:

Non-sensitive——These scopes provide the smallest sphere of
authorization access and only require basic app verification. For information
about this requirement, see
Steps to prepare for verification.
Sensitive—These scopes allow access to Google User Data and require
a sensitive scope verification process. For information on this requirement, see
Google API Services: User Data Policy.
These scopes don't require a security assessment.
Restricted—These scopes provide wide access to Google User Data and
require you to go through a restricted scope verification process. For
information about this requirement, see
Google API Services: User Data Policy and
Additional Requirements for Specific API Scopes.
If you store restricted scope data on servers (or transmit), then you need to
go through a security assessment.

Additional information that governs your use and access to Gmail APIs when you
request to access user data can be found in the
Gmail API Services User Data and Developer Policy.
If your app requires access to any other Google APIs, you can add
those scopes as well. For more information about Google API scopes,
see
Using OAuth 2.0 to Access Google APIs.
OAuth verification
Using certain sensitive OAuth scopes might require that your app go through
Google's OAuth verification process.
Read the OAuth verification FAQ
to determine when your app should go through verification and what type of
verification is required. See also the
Google API Services: User Data Policy.


Requests to the Gmail API must be authorized using OAuth 2.0
credentials. You should use server-side flow when your application
needs to access Google APIs on behalf of the user, for example when the user is
offline. This approach requires passing a one-time authorization code from
your client to your server; this code is used to acquire an access token and
refresh tokens for your server.
To learn more about server-side Google OAuth 2.0 implementation, see
Using OAuth 2.0 for Web Server Applications.
Contents
Create a client ID and client secret
To get started using Gmail API, you need to first
use
the setup tool, which guides you through creating a project in the
Google API Console, enabling the API, and creating credentials.

From the Credentials page, click Create credentials > OAuth client
ID to create your OAuth 2.0 credentials or Create credentials > Service
account key to create a service account.
If you created an OAuth client ID, then select your application type.
Fill in the form and click Create.

Your application's client IDs and service account keys are now listed on
the Credentials page. For details, click a client ID; parameters vary
depending on the ID type, but might include email address, client secret,
JavaScript origins, or redirect URIs.
Take note of the Client ID as you'll need to add it to your code later.
Handling authorization requests
When a user loads your application for the first time, they are presented with
a dialog to grant permission for your application to access their Gmail
account with the requested permission scopes. After this initial
authorization, the user is only presented with the permission dialog if your
app's client ID changes or the requested scopes have changed.
Authenticate the user
This initial sign-in returns an authorization result object that contains an
authorization code if successful.
Exchange the authorization code for an access token
The authorization code is a one-time code that your server can exchange for
an access token. This access token is passed to the Gmail API to grant
your application access to user data for a limited time.
If your application requires offline access, the first time your app exchanges
the authorization code, it also receives a refresh token that it uses to
receive a new access token after a previous token has expired. Your application
stores this refresh token (generally in a database on your server) for
later use.
Important: Always store user refresh tokens. If your application needs a new
refresh token it must send a request with the approval_prompt query parameter
set to force. This will cause the user to see a dialog to grant permission
to your application again.
The following code samples demonstrate exchanging an authorization code for
an access token with offline access and storing the refresh token.

PythonReplace CLIENTSECRETS_LOCATION value with the location of your
client_secrets.json file.
import logging
from oauth2client.client import flow_from_clientsecrets
from oauth2client.client import FlowExchangeError
from apiclient.discovery import build
# ...


# Path to client_secrets.json which should contain a JSON document such as:
#   {
#     "web": {
#       "client_id": "[[YOUR_CLIENT_ID]]",
#       "client_secret": "[[YOUR_CLIENT_SECRET]]",
#       "redirect_uris": [],
#       "auth_uri": "https://accounts.google.com/o/oauth2/auth",
#       "token_uri": "https://accounts.google.com/o/oauth2/token"
#     }
#   }
CLIENTSECRETS_LOCATION = '<PATH/TO/CLIENT_SECRETS.JSON>'
REDIRECT_URI = '<YOUR_REGISTERED_REDIRECT_URI>'
SCOPES = [
    'https://www.googleapis.com/auth/gmail.readonly',
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
    # Add other requested scopes.
]

class GetCredentialsException(Exception):
  """Error raised when an error occurred while retrieving credentials.

  Attributes:
    authorization_url: Authorization URL to redirect the user to in order to
                       request offline access.
  """

  def __init__(self, authorization_url):
    """Construct a GetCredentialsException."""
    self.authorization_url = authorization_url


class CodeExchangeException(GetCredentialsException):
  """Error raised when a code exchange has failed."""


class NoRefreshTokenException(GetCredentialsException):
  """Error raised when no refresh token has been found."""


class NoUserIdException(Exception):
  """Error raised when no user ID could be retrieved."""


def get_stored_credentials(user_id):
  """Retrieved stored credentials for the provided user ID.

  Args:
    user_id: User's ID.
  Returns:
    Stored oauth2client.client.OAuth2Credentials if found, None otherwise.
  Raises:
    NotImplemented: This function has not been implemented.
  """
  # TODO: Implement this function to work with your database.
  #       To instantiate an OAuth2Credentials instance from a Json
  #       representation, use the oauth2client.client.Credentials.new_from_json
  #       class method.
  raise NotImplementedError()


def store_credentials(user_id, credentials):
  """Store OAuth 2.0 credentials in the application's database.

  This function stores the provided OAuth 2.0 credentials using the user ID as
  key.

  Args:
    user_id: User's ID.
    credentials: OAuth 2.0 credentials to store.
  Raises:
    NotImplemented: This function has not been implemented.
  """
  # TODO: Implement this function to work with your database.
  #       To retrieve a Json representation of the credentials instance, call the
  #       credentials.to_json() method.
  raise NotImplementedError()


def exchange_code(authorization_code):
  """Exchange an authorization code for OAuth 2.0 credentials.

  Args:
    authorization_code: Authorization code to exchange for OAuth 2.0
                        credentials.
  Returns:
    oauth2client.client.OAuth2Credentials instance.
  Raises:
    CodeExchangeException: an error occurred.
  """
  flow = flow_from_clientsecrets(CLIENTSECRETS_LOCATION, ' '.join(SCOPES))
  flow.redirect_uri = REDIRECT_URI
  try:
    credentials = flow.step2_exchange(authorization_code)
    return credentials
  except FlowExchangeError, error:
    logging.error('An error occurred: %s', error)
    raise CodeExchangeException(None)


def get_user_info(credentials):
  """Send a request to the UserInfo API to retrieve the user's information.

  Args:
    credentials: oauth2client.client.OAuth2Credentials instance to authorize the
                 request.
  Returns:
    User information as a dict.
  """
  user_info_service = build(
      serviceName='oauth2', version='v2',
      http=credentials.authorize(httplib2.Http()))
  user_info = None
  try:
    user_info = user_info_service.userinfo().get().execute()
  except errors.HttpError, e:
    logging.error('An error occurred: %s', e)
  if user_info and user_info.get('id'):
    return user_info
  else:
    raise NoUserIdException()


def get_authorization_url(email_address, state):
  """Retrieve the authorization URL.

  Args:
    email_address: User's e-mail address.
    state: State for the authorization URL.
  Returns:
    Authorization URL to redirect the user to.
  """
  flow = flow_from_clientsecrets(CLIENTSECRETS_LOCATION, ' '.join(SCOPES))
  flow.params['access_type'] = 'offline'
  flow.params['approval_prompt'] = 'force'
  flow.params['user_id'] = email_address
  flow.params['state'] = state
  return flow.step1_get_authorize_url(REDIRECT_URI)


def get_credentials(authorization_code, state):
  """Retrieve credentials using the provided authorization code.

  This function exchanges the authorization code for an access token and queries
  the UserInfo API to retrieve the user's e-mail address.
  If a refresh token has been retrieved along with an access token, it is stored
  in the application database using the user's e-mail address as key.
  If no refresh token has been retrieved, the function checks in the application
  database for one and returns it if found or raises a NoRefreshTokenException
  with the authorization URL to redirect the user to.

  Args:
    authorization_code: Authorization code to use to retrieve an access token.
    state: State to set to the authorization URL in case of error.
  Returns:
    oauth2client.client.OAuth2Credentials instance containing an access and
    refresh token.
  Raises:
    CodeExchangeError: Could not exchange the authorization code.
    NoRefreshTokenException: No refresh token could be retrieved from the
                             available sources.
  """
  email_address = ''
  try:
    credentials = exchange_code(authorization_code)
    user_info = get_user_info(credentials)
    email_address = user_info.get('email')
    user_id = user_info.get('id')
    if credentials.refresh_token is not None:
      store_credentials(user_id, credentials)
      return credentials
    else:
      credentials = get_stored_credentials(user_id)
      if credentials and credentials.refresh_token is not None:
        return credentials
  except CodeExchangeException, error:
    logging.error('An error occurred during code exchange.')
    # Drive apps should try to retrieve the user and credentials for the current
    # session.
    # If none is available, redirect the user to the authorization URL.
    error.authorization_url = get_authorization_url(email_address, state)
    raise error
  except NoUserIdException:
    logging.error('No user ID could be retrieved.')
  # No refresh token has been retrieved.
  authorization_url = get_authorization_url(email_address, state)
  raise NoRefreshTokenException(authorization_url)



Authorizing with stored credentials
When users visit your app after a successful first-time authorization
flow, your application can use a stored refresh token to authorize requests
without prompting the user again.
If you have already authenticated the user, your application can retrieve
the refresh token from its database and store the token in a server-side
session. If the refresh token is revoked or is otherwise invalid, you'll
need to catch this and take appropriate action.
Using OAuth 2.0 credentials
Once OAuth 2.0 credentials have been retrieved as shown in the
previous section, they can be used to authorize a Gmail service object
and send requests to the API.
Instantiate a service object
This code sample shows how to instantiate a service object and then authorize
it to make API requests.

Pythonfrom apiclient.discovery import build
# ...

def build_service(credentials):
  """Build a Gmail service object.

  Args:
    credentials: OAuth 2.0 credentials.

  Returns:
    Gmail service object.
  """
  http = httplib2.Http()
  http = credentials.authorize(http)
  return build('gmail', 'v1', http=http)


Send authorized requests and check for revoked credentials
The following code snippet uses an authorized Gmail service instance to
retrieve a list of messages.
If an error occurs, the code checks for an HTTP 401 status code,
which should be handled by redirecting the user to the authorization
URL.
More Gmail API operations are documented in the API Reference.

Pythonfrom apiclient import errors
# ...

def ListMessages(service, user, query=''):
  """Gets a list of messages.

  Args:
    service: Authorized Gmail API service instance.
    user: The email address of the account.
    query: String used to filter messages returned.
           Eg.- 'label:UNREAD' for unread Messages only.

  Returns:
    List of messages that match the criteria of the query. Note that the
    returned list contains Message IDs, you must use get with the
    appropriate id to get the details of a Message.
  """
  try:
    response = service.users().messages().list(userId=user, q=query).execute()
    messages = response['messages']

    while 'nextPageToken' in response:
      page_token = response['nextPageToken']
      response = service.users().messages().list(userId=user, q=query,
                                         pageToken=page_token).execute()
      messages.extend(response['messages'])

    return messages
  except errors.HttpError, error:
    print 'An error occurred: %s' % error
    if error.resp.status == 401:
      # Credentials have been revoked.
      # TODO: Redirect the user to the authorization URL.
      raise NotImplementedError()


Next steps
Once you are comfortable authorizing Gmail API requests, you're ready to
start handling messages, threads, and labels, as described in the
Developers Guides sections.
You can learn more about the available API methods in the
API Reference.
Warning: When testing your app
during development, be sure to use a test Gmail account that you
don't care about. This will prevent you from accidentally causing havoc
with your actual emails, threads, and labels.


Quickstarts explain how to set up and run an app that calls a
Google Workspace API.
Google Workspace quickstarts use the API client libraries to handle some
details of the authentication and authorization flow. We recommend that
you use the client libraries for your own apps. This quickstart uses a
simplified authentication approach that is appropriate for a testing
environment. For a production environment, we recommend learning about
authentication and authorization
before
choosing the access credentials
that are appropriate for your app.
Create a JavaScript web application that makes requests to the Gmail API.
Objectives

Set up your environment.
Set up the sample.
Run the sample.

Prerequisites

Node.js & npm 
installed.
A Google Cloud
project.

A Google account with Gmail enabled.
Set up your environment
To complete this quickstart, set up your environment.
Enable the API

Before using Google APIs, you need to turn them on in a Google Cloud project.
You can turn on one or more APIs in a single Google Cloud project.



In the Google Cloud console, enable the Gmail API.
Enable the API

Configure the OAuth consent screen
If you're using a new Google Cloud project to complete this quickstart, configure
the OAuth consent screen and add yourself as a test user. If you've already
completed this step for your Cloud project, skip to the next section.


    In the Google Cloud console, go to Menu menu
> APIs & Services
> OAuth consent screen.
  Go to OAuth consent screen
For User type select Internal, then click Create.
Complete the app registration form, then click Save and Continue.
For now, you can skip adding scopes and click Save and Continue.
  In the future, when you create an app for use outside of your
  Google Workspace organization, you must change the User type to External, and then,
  add the authorization scopes that your app requires.
Review your app registration summary. To make changes, click Edit. If the app
    registration looks OK, click Back to Dashboard.

Authorize credentials for a web application

To authenticate end users and access user data in your app, you need to
create one or more OAuth 2.0 Client IDs. A client ID is used to identify a
single app to Google's OAuth servers. If your app runs on multiple platforms,
you must create a separate client ID for each platform.



  In the Google Cloud console, go to Menu menu > APIs & Services > Credentials.
  Go to Credentials

Click Create Credentials > OAuth client ID.
Click Application type > Web application.
In the Name field, type a name for the credential. This name is only shown in the Google Cloud console.
Add authorized URIs related to your app:
  
Client-side apps (JavaScript)–Under Authorized JavaScript origins, click Add URI. Then, enter a URI to use for browser requests. This identifies the domains from which your application can send API requests to the OAuth 2.0 server.
Server-side apps (Java, Python, and more)–Under Authorized redirect URIs, click Add URI. Then, enter an endpoint URI to which the OAuth 2.0 server can send responses.


Click Create. The OAuth client created screen appears, showing your new Client ID and Client secret.
  Note the Client ID. Client secrets aren't used for Web applications.
Click OK. The newly created credential appears under OAuth 2.0 Client IDs.

Make a note of these credentials because you need them later in this quickstart.
Create an API key


    In the Google Cloud console, go to Menu menu
> APIs & Services
> Credentials.
    Go to Credentials

Click Create credentials >
API key.
Your new API key is displayed.
    
Click Copy content_copy
      to copy your API key for use in your app's code. The API key can also be
      found in the "API keys" section of your project's credentials.
Click Restrict key to update advanced settings and limit use
        of your API key. For more details, see Applying API key restrictions.



Set up the sample

In your working directory, create a file named index.html.
In the index.html file, paste the following sample code:



gmail/quickstart/index.html

View on GitHub



<!DOCTYPE html>
<html>
  <head>
    <title>Gmail API Quickstart</title>
    <meta charset="utf-8" />
  </head>
  <body>
    <p>Gmail API Quickstart</p>

    <!--Add buttons to initiate auth sequence and sign out-->
    <button id="authorize_button" onclick="handleAuthClick()">Authorize</button>
    <button id="signout_button" onclick="handleSignoutClick()">Sign Out</button>

    <pre id="content" style="white-space: pre-wrap;"></pre>

    <script type="text/javascript">
      /* exported gapiLoaded */
      /* exported gisLoaded */
      /* exported handleAuthClick */
      /* exported handleSignoutClick */

      // TODO(developer): Set to client ID and API key from the Developer Console
      const CLIENT_ID = '<YOUR_CLIENT_ID>';
      const API_KEY = '<YOUR_API_KEY>';

      // Discovery doc URL for APIs used by the quickstart
      const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest';

      // Authorization scopes required by the API; multiple scopes can be
      // included, separated by spaces.
      const SCOPES = 'https://www.googleapis.com/auth/gmail.readonly';

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      document.getElementById('authorize_button').style.visibility = 'hidden';
      document.getElementById('signout_button').style.visibility = 'hidden';

      /**
       * Callback after api.js is loaded.
       */
      function gapiLoaded() {
        gapi.load('client', initializeGapiClient);
      }

      /**
       * Callback after the API client is loaded. Loads the
       * discovery doc to initialize the API.
       */
      async function initializeGapiClient() {
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: [DISCOVERY_DOC],
        });
        gapiInited = true;
        maybeEnableButtons();
      }

      /**
       * Callback after Google Identity Services are loaded.
       */
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: '', // defined later
        });
        gisInited = true;
        maybeEnableButtons();
      }

      /**
       * Enables user interaction after all libraries are loaded.
       */
      function maybeEnableButtons() {
        if (gapiInited && gisInited) {
          document.getElementById('authorize_button').style.visibility = 'visible';
        }
      }

      /**
       *  Sign in the user upon button click.
       */
      function handleAuthClick() {
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) {
            throw (resp);
          }
          document.getElementById('signout_button').style.visibility = 'visible';
          document.getElementById('authorize_button').innerText = 'Refresh';
          await listLabels();
        };

        if (gapi.client.getToken() === null) {
          // Prompt the user to select a Google Account and ask for consent to share their data
          // when establishing a new session.
          tokenClient.requestAccessToken({prompt: 'consent'});
        } else {
          // Skip display of account chooser and consent dialog for an existing session.
          tokenClient.requestAccessToken({prompt: ''});
        }
      }

      /**
       *  Sign out the user upon button click.
       */
      function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
          google.accounts.oauth2.revoke(token.access_token);
          gapi.client.setToken('');
          document.getElementById('content').innerText = '';
          document.getElementById('authorize_button').innerText = 'Authorize';
          document.getElementById('signout_button').style.visibility = 'hidden';
        }
      }

      /**
       * Print all Labels in the authorized user's inbox. If no labels
       * are found an appropriate message is printed.
       */
      async function listLabels() {
        let response;
        try {
          response = await gapi.client.gmail.users.labels.list({
            'userId': 'me',
          });
        } catch (err) {
          document.getElementById('content').innerText = err.message;
          return;
        }
        const labels = response.result.labels;
        if (!labels || labels.length == 0) {
          document.getElementById('content').innerText = 'No labels found.';
          return;
        }
        // Flatten to string to display
        const output = labels.reduce(
            (str, label) => `${str}${label.name}\n`,
            'Labels:\n');
        document.getElementById('content').innerText = output;
      }
    </script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
  </body>
</html>


Replace the following:

YOUR_CLIENT_ID: the client ID that you created
when you
authorized credentials for a web application.
YOUR_API_KEY: the API key that you created as
a Prerequisite.


Run the sample

In your working directory, install the http-server package:


npm install http-server


In your working directory, start a web server:


npx http-server -p 8000




In your browser, navigate to http://localhost:8000.

    You see a prompt to authorize access:
    

        If you're not already signed in to your Google Account, sign in when prompted. If
        you're signed in to multiple accounts, select one account to use for authorization.
      
Click Accept.




  Your JavaScript application runs and calls the Gmail API.

Next steps

Troubleshoot authentication and authorization issues
Gmail API reference documentation
google-api-javascript-client section of GitHub



Quickstarts explain how to set up and run an app that calls a
Google Workspace API.
Google Workspace quickstarts use the API client libraries to handle some
details of the authentication and authorization flow. We recommend that
you use the client libraries for your own apps. This quickstart uses a
simplified authentication approach that is appropriate for a testing
environment. For a production environment, we recommend learning about
authentication and authorization
before
choosing the access credentials
that are appropriate for your app.
Create a Java command-line application that makes requests to the Gmail API.
Objectives

Set up your environment.
Set up the sample.
Run the sample.

Prerequisites

Java 1.8 or greater.
Gradle 7.0 or greater.
A Google Cloud project.

A Google account with Gmail enabled.
Set up your environment
To complete this quickstart, set up your environment.
Enable the API

Before using Google APIs, you need to turn them on in a Google Cloud project.
You can turn on one or more APIs in a single Google Cloud project.




In the Google Cloud console, enable the Gmail API.
Enable the API

Configure the OAuth consent screen
If you're using a new Google Cloud project to complete this quickstart, configure
the OAuth consent screen and add yourself as a test user. If you've already
completed this step for your Cloud project, skip to the next section.


    In the Google Cloud console, go to Menu menu
> APIs & Services
> OAuth consent screen.
  Go to OAuth consent screen
For User type select Internal, then click Create.
Complete the app registration form, then click Save and Continue.
For now, you can skip adding scopes and click Save and Continue.
  In the future, when you create an app for use outside of your
  Google Workspace organization, you must change the User type to External, and then,
  add the authorization scopes that your app requires.
Review your app registration summary. To make changes, click Edit. If the app
    registration looks OK, click Back to Dashboard.

Authorize credentials for a desktop application

To authenticate end users and access user data in your app, you need to
create one or more OAuth 2.0 Client IDs. A client ID is used to identify a
single app to Google's OAuth servers. If your app runs on multiple platforms,
you must create a separate client ID for each platform.



  In the Google Cloud console, go to Menu menu > APIs & Services > Credentials.
  Go to Credentials

Click Create Credentials > OAuth client ID.
Click Application type > Desktop app.
In the Name field, type a name for the credential. This name is only shown in the Google Cloud console.
Click Create. The OAuth client created screen appears, showing your new Client ID and Client secret.
Click OK. The newly created credential appears under OAuth 2.0 Client IDs.
Save the downloaded JSON file as credentials.json, and move the
  file to your working directory.

Prepare the workspace

In your working directory, create a new project structure:
gradle init --type basic
mkdir -p src/main/java src/main/resources 

In the src/main/resources/ directory, copy the credentials.json file
that you previously downloaded.
Open the default build.gradle file and replace its contents with the
following code:



gmail/quickstart/build.gradle

View on GitHub



apply plugin: 'java'
apply plugin: 'application'

mainClassName = 'GmailQuickstart'
sourceCompatibility = 11
targetCompatibility = 11
version = '1.0'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.api-client:google-api-client:2.0.0'
    implementation 'com.google.oauth-client:google-oauth-client-jetty:1.34.1'
    implementation 'com.google.apis:google-api-services-gmail:v1-rev20220404-2.0.0'
}





Set up the sample

In the src/main/java/ directory, create a new Java file with a name that
matches the mainClassName value in your build.gradle file.
Include the following code in your new Java file:



gmail/quickstart/src/main/java/GmailQuickstart.java

View on GitHub




import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Label;
import com.google.api.services.gmail.model.ListLabelsResponse;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.GeneralSecurityException;
import java.util.Collections;
import java.util.List;

/* class to demonstrate use of Gmail list labels API */
public class GmailQuickstart {
  /**
   * Application name.
   */
  private static final String APPLICATION_NAME = "Gmail API Java Quickstart";
  /**
   * Global instance of the JSON factory.
   */
  private static final JsonFactory JSON_FACTORY = GsonFactory.getDefaultInstance();
  /**
   * Directory to store authorization tokens for this application.
   */
  private static final String TOKENS_DIRECTORY_PATH = "tokens";

  /**
   * Global instance of the scopes required by this quickstart.
   * If modifying these scopes, delete your previously saved tokens/ folder.
   */
  private static final List<String> SCOPES = Collections.singletonList(GmailScopes.GMAIL_LABELS);
  private static final String CREDENTIALS_FILE_PATH = "/credentials.json";

  /**
   * Creates an authorized Credential object.
   *
   * @param HTTP_TRANSPORT The network HTTP Transport.
   * @return An authorized Credential object.
   * @throws IOException If the credentials.json file cannot be found.
   */
  private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)
      throws IOException {
    // Load client secrets.
    InputStream in = GmailQuickstart.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
    if (in == null) {
      throw new FileNotFoundException("Resource not found: " + CREDENTIALS_FILE_PATH);
    }
    GoogleClientSecrets clientSecrets =
        GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));

    // Build flow and trigger user authorization request.
    GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(
        HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
        .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
        .setAccessType("offline")
        .build();
    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
    Credential credential = new AuthorizationCodeInstalledApp(flow, receiver).authorize("user");
    //returns an authorized Credential object.
    return credential;
  }

  public static void main(String... args) throws IOException, GeneralSecurityException {
    // Build a new authorized API client service.
    final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Gmail service = new Gmail.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))
        .setApplicationName(APPLICATION_NAME)
        .build();

    // Print the labels in the user's account.
    String user = "me";
    ListLabelsResponse listResponse = service.users().labels().list(user).execute();
    List<Label> labels = listResponse.getLabels();
    if (labels.isEmpty()) {
      System.out.println("No labels found.");
    } else {
      System.out.println("Labels:");
      for (Label label : labels) {
        System.out.printf("- %s\n", label.getName());
      }
    }
  }
}




Run the sample

Run the sample:

gradle run




    The first time you run the sample, it prompts you to authorize access:
    

        If you're not already signed in to your Google Account, sign in when prompted. If
        you're signed in to multiple accounts, select one account to use for authorization.
      
Click Accept.


      Your Java application runs and calls the Gmail API.
    

      Authorization information is stored in the file system, so the next time you run the sample
      code, you aren't prompted for authorization.
    


Next steps

Troubleshoot authentication and authorization issues
Gmail API reference documentation
Google APIs Client for Java documentation
Gmail API Javadoc documentation



Quickstarts explain how to set up and run an app that calls a
Google Workspace API.
Google Workspace quickstarts use the API client libraries to handle some
details of the authentication and authorization flow. We recommend that
you use the client libraries for your own apps. This quickstart uses a
simplified authentication approach that is appropriate for a testing
environment. For a production environment, we recommend learning about
authentication and authorization
before
choosing the access credentials
that are appropriate for your app.
Create a Python command-line application that makes requests to the Gmail API.
Objectives

Set up your environment.
Install the client library.
Set up the sample.
Run the sample.

Prerequisites
To run this quickstart, you need the following prerequisites:

Python 3.10.7 or greater
The pip 
package management tool
A Google Cloud project.

A Google account with Gmail enabled.
Set up your environment
To complete this quickstart, set up your environment.
Enable the API

Before using Google APIs, you need to turn them on in a Google Cloud project.
You can turn on one or more APIs in a single Google Cloud project.




In the Google Cloud console, enable the Gmail API.
Enable the API

Configure the OAuth consent screen
If you're using a new Google Cloud project to complete this quickstart, configure
the OAuth consent screen and add yourself as a test user. If you've already
completed this step for your Cloud project, skip to the next section.


    In the Google Cloud console, go to Menu menu
> APIs & Services
> OAuth consent screen.
  Go to OAuth consent screen
For User type select Internal, then click Create.
Complete the app registration form, then click Save and Continue.
For now, you can skip adding scopes and click Save and Continue.
  In the future, when you create an app for use outside of your
  Google Workspace organization, you must change the User type to External, and then,
  add the authorization scopes that your app requires.
Review your app registration summary. To make changes, click Edit. If the app
    registration looks OK, click Back to Dashboard.

Authorize credentials for a desktop application

To authenticate end users and access user data in your app, you need to
create one or more OAuth 2.0 Client IDs. A client ID is used to identify a
single app to Google's OAuth servers. If your app runs on multiple platforms,
you must create a separate client ID for each platform.



  In the Google Cloud console, go to Menu menu > APIs & Services > Credentials.
  Go to Credentials

Click Create Credentials > OAuth client ID.
Click Application type > Desktop app.
In the Name field, type a name for the credential. This name is only shown in the Google Cloud console.
Click Create. The OAuth client created screen appears, showing your new Client ID and Client secret.
Click OK. The newly created credential appears under OAuth 2.0 Client IDs.
Save the downloaded JSON file as credentials.json, and move the
  file to your working directory.

Install the Google client library

Install the Google client library for Python:
pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib


Configure the sample

In your working directory, create a file named quickstart.py.
Include the following code in quickstart.py:



gmail/quickstart/quickstart.py

View on GitHub



import os.path

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# If modifying these scopes, delete the file token.json.
SCOPES = ["https://www.googleapis.com/auth/gmail.readonly"]


def main():
  """Shows basic usage of the Gmail API.
  Lists the user's Gmail labels.
  """
  creds = None
  # The file token.json stores the user's access and refresh tokens, and is
  # created automatically when the authorization flow completes for the first
  # time.
  if os.path.exists("token.json"):
    creds = Credentials.from_authorized_user_file("token.json", SCOPES)
  # If there are no (valid) credentials available, let the user log in.
  if not creds or not creds.valid:
    if creds and creds.expired and creds.refresh_token:
      creds.refresh(Request())
    else:
      flow = InstalledAppFlow.from_client_secrets_file(
          "credentials.json", SCOPES
      )
      creds = flow.run_local_server(port=0)
    # Save the credentials for the next run
    with open("token.json", "w") as token:
      token.write(creds.to_json())

  try:
    # Call the Gmail API
    service = build("gmail", "v1", credentials=creds)
    results = service.users().labels().list(userId="me").execute()
    labels = results.get("labels", [])

    if not labels:
      print("No labels found.")
      return
    print("Labels:")
    for label in labels:
      print(label["name"])

  except HttpError as error:
    # TODO(developer) - Handle errors from gmail API.
    print(f"An error occurred: {error}")


if __name__ == "__main__":
  main()




Run the sample

In your working directory, build and run the sample:
python3 quickstart.py




    The first time you run the sample, it prompts you to authorize access:
    

        If you're not already signed in to your Google Account, sign in when prompted. If
        you're signed in to multiple accounts, select one account to use for authorization.
      
Click Accept.


      Your Python application runs and calls the Gmail API.
    

      Authorization information is stored in the file system, so the next time you run the sample
      code, you aren't prompted for authorization.
    


Next steps

Troubleshoot authentication and authorization issues
Gmail API reference documentation
Google APIs Client for Python documentation
Gmail API PyDoc documentation



Quickstarts explain how to set up and run an app that calls a
Google Workspace API.
Google Workspace quickstarts use the API client libraries to handle some
details of the authentication and authorization flow. We recommend that
you use the client libraries for your own apps. This quickstart uses a
simplified authentication approach that is appropriate for a testing
environment. For a production environment, we recommend learning about
authentication and authorization
before
choosing the access credentials
that are appropriate for your app.
Create a
Google Apps Script
that makes requests to the Gmail API.
Objectives

Create the script.
Enable the Gmail API.
Run the sample.

Prerequisites
A Google account with Gmail enabled.

Access to Google Drive

Create the script

Create a new script by going to script.google.com/create.
Replace the contents of the script editor with the following code:




gmail/quickstart/quickstart.gs

View on GitHub



/**
 * Lists all labels in the user's mailbox
 * @see https://developers.google.com/gmail/api/reference/rest/v1/users.labels/list
 */
function listLabels() {
  try {
    // Gmail.Users.Labels.list() API returns the list of all Labels in user's mailbox
    const response = Gmail.Users.Labels.list('me');
    if (!response || response.labels.length === 0) {
      // TODO (developer) - No labels are returned from the response
      console.log('No labels found.');
      return;
    }
    // Print the Labels that are available.
    console.log('Labels:');
    for (const label of response.labels ) {
      console.log('- %s', label.name);
    }
  } catch (err) {
    // TODO (developer) - Handle exception on Labels.list() API
    console.log('Labels.list() API failed with error %s', err.toString());
  }
}


Click Save .
Click Untitled project, type
   Quickstart, and click Rename.
Enable the Gmail API

Open the Apps Script project.
Click Editor code.
Next to Services, click Add a service
 add .
Select
   Gmail API
 and click Add.

Run the sample
In the Apps Script editor, click Run.
The first time you run the sample, it prompts you to authorize access:

Click Review permissions.
Choose an account.
Click Allow.

The script's execution log appears at the bottom of the window.




done
      It worked!
    

Great!
      Check out the further reading section below to learn more.
    



warning
      There was a problem
    

Bummer,
      
      
      let us know what went wrong.
      
      
    Check out our 
    troubleshooting section below for some common errors and solutions.
  
      
      If you have found a bug in the code,
      
      report the issue on GitHub or submit a pull request.
      
    


Next steps

Google Apps Script Advanced Services documentation
Troubleshoot authentication and authorization issues
Gmail API reference documentation




Quickstarts explain how to set up and run an app that calls a
Google Workspace API.
Google Workspace quickstarts use the API client libraries to handle some
details of the authentication and authorization flow. We recommend that
you use the client libraries for your own apps. This quickstart uses a
simplified authentication approach that is appropriate for a testing
environment. For a production environment, we recommend learning about
authentication and authorization
before
choosing the access credentials
that are appropriate for your app.
Create a Go command-line application that makes requests to the
Gmail API.
Objectives

Set up your environment.
Set up the sample.
Run the sample.

Prerequisites

Latest version of Go.
Latest version of Git.
A Google Cloud project.

A Google account with Gmail enabled.
Set up your environment
To complete this quickstart, set up your environment.
Enable the API

Before using Google APIs, you need to turn them on in a Google Cloud project.
You can turn on one or more APIs in a single Google Cloud project.



In the Google Cloud console, enable the Gmail API.
Enable the API

Configure the OAuth consent screen
If you're using a new Google Cloud project to complete this quickstart, configure
the OAuth consent screen and add yourself as a test user. If you've already
completed this step for your Cloud project, skip to the next section.


    In the Google Cloud console, go to Menu menu
> APIs & Services
> OAuth consent screen.
  Go to OAuth consent screen
For User type select Internal, then click Create.
Complete the app registration form, then click Save and Continue.
For now, you can skip adding scopes and click Save and Continue.
  In the future, when you create an app for use outside of your
  Google Workspace organization, you must change the User type to External, and then,
  add the authorization scopes that your app requires.
Review your app registration summary. To make changes, click Edit. If the app
    registration looks OK, click Back to Dashboard.

Authorize credentials for a desktop application

To authenticate end users and access user data in your app, you need to
create one or more OAuth 2.0 Client IDs. A client ID is used to identify a
single app to Google's OAuth servers. If your app runs on multiple platforms,
you must create a separate client ID for each platform.



  In the Google Cloud console, go to Menu menu > APIs & Services > Credentials.
  Go to Credentials

Click Create Credentials > OAuth client ID.
Click Application type > Desktop app.
In the Name field, type a name for the credential. This name is only shown in the Google Cloud console.
Click Create. The OAuth client created screen appears, showing your new Client ID and Client secret.
Click OK. The newly created credential appears under OAuth 2.0 Client IDs.
Save the downloaded JSON file as credentials.json, and move the
  file to your working directory.

Prepare the workspace

Create a working directory:

mkdir quickstart

Change to the working directory:

cd quickstart

Initialize the new module:

go mod init quickstart

Get the Gmail API Go client library and OAuth2.0 package:
go get google.golang.org/api/gmail/v1
go get golang.org/x/oauth2/google


Set up the sample

In your working directory, create a file named quickstart.go.
In the file, paste the following code:



gmail/quickstart/quickstart.go

View on GitHub



package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/option"
)

// Retrieve a token, saves the token, then returns the generated client.
func getClient(config *oauth2.Config) *http.Client {
	// The file token.json stores the user's access and refresh tokens, and is
	// created automatically when the authorization flow completes for the first
	// time.
	tokFile := "token.json"
	tok, err := tokenFromFile(tokFile)
	if err != nil {
		tok = getTokenFromWeb(config)
		saveToken(tokFile, tok)
	}
	return config.Client(context.Background(), tok)
}

// Request a token from the web, then returns the retrieved token.
func getTokenFromWeb(config *oauth2.Config) *oauth2.Token {
	authURL := config.AuthCodeURL("state-token", oauth2.AccessTypeOffline)
	fmt.Printf("Go to the following link in your browser then type the "+
		"authorization code: \n%v\n", authURL)

	var authCode string
	if _, err := fmt.Scan(&authCode); err != nil {
		log.Fatalf("Unable to read authorization code: %v", err)
	}

	tok, err := config.Exchange(context.TODO(), authCode)
	if err != nil {
		log.Fatalf("Unable to retrieve token from web: %v", err)
	}
	return tok
}

// Retrieves a token from a local file.
func tokenFromFile(file string) (*oauth2.Token, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	tok := &oauth2.Token{}
	err = json.NewDecoder(f).Decode(tok)
	return tok, err
}

// Saves a token to a file path.
func saveToken(path string, token *oauth2.Token) {
	fmt.Printf("Saving credential file to: %s\n", path)
	f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("Unable to cache oauth token: %v", err)
	}
	defer f.Close()
	json.NewEncoder(f).Encode(token)
}

func main() {
	ctx := context.Background()
	b, err := os.ReadFile("credentials.json")
	if err != nil {
		log.Fatalf("Unable to read client secret file: %v", err)
	}

	// If modifying these scopes, delete your previously saved token.json.
	config, err := google.ConfigFromJSON(b, gmail.GmailReadonlyScope)
	if err != nil {
		log.Fatalf("Unable to parse client secret file to config: %v", err)
	}
	client := getClient(config)

	srv, err := gmail.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		log.Fatalf("Unable to retrieve Gmail client: %v", err)
	}

	user := "me"
	r, err := srv.Users.Labels.List(user).Do()
	if err != nil {
		log.Fatalf("Unable to retrieve labels: %v", err)
	}
	if len(r.Labels) == 0 {
		fmt.Println("No labels found.")
		return
	}
	fmt.Println("Labels:")
	for _, l := range r.Labels {
		fmt.Printf("- %s\n", l.Name)
	}
}




Run the sample

In your working directory, build and run the sample:

go run quickstart.go




    The first time you run the sample, it prompts you to authorize access:
    

        If you're not already signed in to your Google Account, sign in when prompted. If
        you're signed in to multiple accounts, select one account to use for authorization.
      
Click Accept.


      Your Go application runs and calls the Gmail API.
    

      Authorization information is stored in the file system, so the next time you run the sample
      code, you aren't prompted for authorization.
    


Next steps

Troubleshoot authentication and authorization issues
Gmail API reference documentation
google-api-go-client section of GitHub



Quickstarts explain how to set up and run an app that calls a
Google Workspace API.
Google Workspace quickstarts use the API client libraries to handle some
details of the authentication and authorization flow. We recommend that
you use the client libraries for your own apps. This quickstart uses a
simplified authentication approach that is appropriate for a testing
environment. For a production environment, we recommend learning about
authentication and authorization
before
choosing the access credentials
that are appropriate for your app.
Create a Node.js command-line application that makes requests to the
Gmail API.
Objectives

Set up your environment.
Install the client library.
Set up the sample.
Run the sample.

Prerequisites
To run this quickstart, you need the following prerequisites:

Node.js & npm installed.
A Google Cloud project.

A Google account with Gmail enabled.
Set up your environment
To complete this quickstart, set up your environment.
Enable the API

Before using Google APIs, you need to turn them on in a Google Cloud project.
You can turn on one or more APIs in a single Google Cloud project.




In the Google Cloud console, enable the Gmail API.
Enable the API

Configure the OAuth consent screen
If you're using a new Google Cloud project to complete this quickstart, configure
the OAuth consent screen and add yourself as a test user. If you've already
completed this step for your Cloud project, skip to the next section.


    In the Google Cloud console, go to Menu menu
> APIs & Services
> OAuth consent screen.
  Go to OAuth consent screen
For User type select Internal, then click Create.
Complete the app registration form, then click Save and Continue.
For now, you can skip adding scopes and click Save and Continue.
  In the future, when you create an app for use outside of your
  Google Workspace organization, you must change the User type to External, and then,
  add the authorization scopes that your app requires.
Review your app registration summary. To make changes, click Edit. If the app
    registration looks OK, click Back to Dashboard.

Authorize credentials for a desktop application

To authenticate end users and access user data in your app, you need to
create one or more OAuth 2.0 Client IDs. A client ID is used to identify a
single app to Google's OAuth servers. If your app runs on multiple platforms,
you must create a separate client ID for each platform.
Caution: This quickstart must be run locally and with access to a browser. It
doesn't work if run on a remote terminal such as Cloud Shell or over SSH.


  In the Google Cloud console, go to Menu menu > APIs & Services > Credentials.
  Go to Credentials

Click Create Credentials > OAuth client ID.
Click Application type > Desktop app.
In the Name field, type a name for the credential. This name is only shown in the Google Cloud console.
Click Create. The OAuth client created screen appears, showing your new Client ID and Client secret.
Click OK. The newly created credential appears under OAuth 2.0 Client IDs.
Save the downloaded JSON file as credentials.json, and move the
  file to your working directory.

Install the client library

Install the libraries using npm:

npm install googleapis@105 @google-cloud/local-auth@2.1.0 --save


Set up the sample

In your working directory, create a file named index.js.
In the file, paste the following code:



gmail/quickstart/index.js

View on GitHub



const fs = require('fs').promises;
const path = require('path');
const process = require('process');
const {authenticate} = require('@google-cloud/local-auth');
const {google} = require('googleapis');

// If modifying these scopes, delete token.json.
const SCOPES = ['https://www.googleapis.com/auth/gmail.readonly'];
// The file token.json stores the user's access and refresh tokens, and is
// created automatically when the authorization flow completes for the first
// time.
const TOKEN_PATH = path.join(process.cwd(), 'token.json');
const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');

/**
 * Reads previously authorized credentials from the save file.
 *
 * @return {Promise<OAuth2Client|null>}
 */
async function loadSavedCredentialsIfExist() {
  try {
    const content = await fs.readFile(TOKEN_PATH);
    const credentials = JSON.parse(content);
    return google.auth.fromJSON(credentials);
  } catch (err) {
    return null;
  }
}

/**
 * Serializes credentials to a file compatible with GoogleAuth.fromJSON.
 *
 * @param {OAuth2Client} client
 * @return {Promise<void>}
 */
async function saveCredentials(client) {
  const content = await fs.readFile(CREDENTIALS_PATH);
  const keys = JSON.parse(content);
  const key = keys.installed || keys.web;
  const payload = JSON.stringify({
    type: 'authorized_user',
    client_id: key.client_id,
    client_secret: key.client_secret,
    refresh_token: client.credentials.refresh_token,
  });
  await fs.writeFile(TOKEN_PATH, payload);
}

/**
 * Load or request or authorization to call APIs.
 *
 */
async function authorize() {
  let client = await loadSavedCredentialsIfExist();
  if (client) {
    return client;
  }
  client = await authenticate({
    scopes: SCOPES,
    keyfilePath: CREDENTIALS_PATH,
  });
  if (client.credentials) {
    await saveCredentials(client);
  }
  return client;
}

/**
 * Lists the labels in the user's account.
 *
 * @param {google.auth.OAuth2} auth An authorized OAuth2 client.
 */
async function listLabels(auth) {
  const gmail = google.gmail({version: 'v1', auth});
  const res = await gmail.users.labels.list({
    userId: 'me',
  });
  const labels = res.data.labels;
  if (!labels || labels.length === 0) {
    console.log('No labels found.');
    return;
  }
  console.log('Labels:');
  labels.forEach((label) => {
    console.log(`- ${label.name}`);
  });
}

authorize().then(listLabels).catch(console.error);





Run the sample

In your working directory, run the sample:

node .




    The first time you run the sample, it prompts you to authorize access:
    

        If you're not already signed in to your Google Account, sign in when prompted. If
        you're signed in to multiple accounts, select one account to use for authorization.
      
Click Accept.


      Your Nodejs application runs and calls the Gmail API.
    

      Authorization information is stored in the file system, so the next time you run the sample
      code, you aren't prompted for authorization.
    


Next steps

Troubleshoot authentication and authorization issues
Gmail API reference documentation
google-api-nodejs-client section of GitHub



Drafts represent unsent messages with the DRAFT system label applied.
The message contained within the draft cannot be edited once created, but it
can be replaced. In this sense, the
draft resource is simply a container
that provides a stable ID because the underlying message IDs change every time
the message is replaced.
Message resources inside a draft
have similar behavior to other messages except for the following differences:

Draft messages cannot have any label other than the DRAFT system label.
When the draft is sent, the draft is automatically deleted and a new message
with an updated ID is created with the SENT system label. This message is
returned in the drafts.send
response.

Contents
Creating draft messages
Your application can create drafts using the
drafts.create method. The
general process is to:

Create a MIME message that complies with
RFC 2822.
Convert the message to a base64url encoded string.
Create a draft, setting the
value of the drafts.message.raw field to the encoded string.

The following code examples demonstrate the process.

Java


gmail/snippets/src/main/java/CreateDraft.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Draft;
import com.google.api.services.gmail.model.Message;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Properties;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import org.apache.commons.codec.binary.Base64;

/* Class to demonstrate the use of Gmail Create Draft API */
public class CreateDraft {
  /**
   * Create a draft email.
   *
   * @param fromEmailAddress - Email address to appear in the from: header
   * @param toEmailAddress   - Email address of the recipient
   * @return the created draft, {@code null} otherwise.
   * @throws MessagingException - if a wrongly formatted address is encountered.
   * @throws IOException        - if service account credentials file not found.
   */
  public static Draft createDraftMessage(String fromEmailAddress,
                                         String toEmailAddress)
      throws MessagingException, IOException {
        /* Load pre-authorized user credentials from the environment.
        TODO(developer) - See https://developers.google.com/identity for
         guides on implementing OAuth2 for your application.*/
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_COMPOSE);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    // Create the email content
    String messageSubject = "Test message";
    String bodyText = "lorem ipsum.";

    // Encode as MIME message
    Properties props = new Properties();
    Session session = Session.getDefaultInstance(props, null);
    MimeMessage email = new MimeMessage(session);
    email.setFrom(new InternetAddress(fromEmailAddress));
    email.addRecipient(javax.mail.Message.RecipientType.TO,
        new InternetAddress(toEmailAddress));
    email.setSubject(messageSubject);
    email.setText(bodyText);

    // Encode and wrap the MIME message into a gmail message
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    email.writeTo(buffer);
    byte[] rawMessageBytes = buffer.toByteArray();
    String encodedEmail = Base64.encodeBase64URLSafeString(rawMessageBytes);
    Message message = new Message();
    message.setRaw(encodedEmail);

    try {
      // Create the draft message
      Draft draft = new Draft();
      draft.setMessage(message);
      draft = service.users().drafts().create("me", draft).execute();
      System.out.println("Draft id: " + draft.getId());
      System.out.println(draft.toPrettyString());
      return draft;
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to create draft: " + e.getMessage());
      } else {
        throw e;
      }
    }
    return null;
  }
}


Python


gmail/snippet/send mail/create_draft.py

View on GitHub



import base64
from email.message import EmailMessage

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_create_draft():
  """Create and insert a draft email.
   Print the returned draft's message and id.
   Returns: Draft object, including draft id and message meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    message = EmailMessage()

    message.set_content("This is automated draft mail")

    message["To"] = "gduser1@workspacesamples.dev"
    message["From"] = "gduser2@workspacesamples.dev"
    message["Subject"] = "Automated draft"

    # encoded message
    encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    create_message = {"message": {"raw": encoded_message}}
    # pylint: disable=E1101
    draft = (
        service.users()
        .drafts()
        .create(userId="me", body=create_message)
        .execute()
    )

    print(f'Draft id: {draft["id"]}\nDraft message: {draft["message"]}')

  except HttpError as error:
    print(f"An error occurred: {error}")
    draft = None

  return draft


if __name__ == "__main__":
  gmail_create_draft()



Updating drafts
Similarly to creating a draft, to update a draft you must supply a Draft
resource in the body of your request with the draft.message.raw field
set to a base64url encoded string containing the MIME message. Because
messages cannot be updated, the message contained in the draft is destroyed
and replaced by the new MIME message supplied in the update request.
You can retrieve the current MIME message contained in the draft by calling
drafts.get with the parameter
format=raw.
For more information, see
drafts.update.
Sending drafts
When sending a draft, you can choose to send the message as-is or as with an
updated message. If you are updating the draft content with a new message,
supply a Draft resource in the body of the
drafts.send request; set the
draft.id of the draft to be sent; and set the draft.message.raw field to the
new MIME message encoded as a base64url encoded string. For more
information, see drafts.send.


There are two ways to send email using the Gmail API:

You can send it directly using the
messages.send method.
You can send it from a draft, using the
drafts.send method.

Emails are sent as base64url encoded strings within the raw property of a
message resource. The high-level
workflow to send an email is to:

Create the email content in some convenient way and encode it as a
base64url string.
Create a new message resource and set its raw property to the base64url
string you just created.
Call messages.send, or, if sending a draft, drafts.send
to send the message.

The details of this workflow can vary depending on your choice of client
library and programming language.
Creating messages
The Gmail API requires MIME email messages compliant with
RFC 2822 and
encoded as base64url strings. Many programming languages have
libraries or utilities that simplify the process of creating and encoding MIME
messages. The following code examples demonstrate how to create a MIME message
using the Google APIs client libraries for various languages.

JavaCreating an email message can be greatly simplified with the MimeMessage
class in the javax.mail.internet package. The following example shows how
to create the email message, including the headers:


gmail/snippets/src/main/java/CreateEmail.java

View on GitHub




import java.util.Properties;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

/* Class to demonstrate the use of Gmail Create Email API  */
public class CreateEmail {

  /**
   * Create a MimeMessage using the parameters provided.
   *
   * @param toEmailAddress   email address of the receiver
   * @param fromEmailAddress email address of the sender, the mailbox account
   * @param subject          subject of the email
   * @param bodyText         body text of the email
   * @return the MimeMessage to be used to send email
   * @throws MessagingException - if a wrongly formatted address is encountered.
   */
  public static MimeMessage createEmail(String toEmailAddress,
                                        String fromEmailAddress,
                                        String subject,
                                        String bodyText)
      throws MessagingException {
    Properties props = new Properties();
    Session session = Session.getDefaultInstance(props, null);

    MimeMessage email = new MimeMessage(session);

    email.setFrom(new InternetAddress(fromEmailAddress));
    email.addRecipient(javax.mail.Message.RecipientType.TO,
        new InternetAddress(toEmailAddress));
    email.setSubject(subject);
    email.setText(bodyText);
    return email;
  }
}

The next step is to encode the MimeMessage, instantiate a Message
object, and set the base64url encoded message string as the value of the
raw property.


gmail/snippets/src/main/java/CreateMessage.java

View on GitHub




import com.google.api.services.gmail.model.Message;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import org.apache.commons.codec.binary.Base64;

/* Class to demonstrate the use of Gmail Create Message API */
public class CreateMessage {

  /**
   * Create a message from an email.
   *
   * @param emailContent Email to be set to raw of message
   * @return a message containing a base64url encoded email
   * @throws IOException        - if service account credentials file not found.
   * @throws MessagingException - if a wrongly formatted address is encountered.
   */
  public static Message createMessageWithEmail(MimeMessage emailContent)
      throws MessagingException, IOException {
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    emailContent.writeTo(buffer);
    byte[] bytes = buffer.toByteArray();
    String encodedEmail = Base64.encodeBase64URLSafeString(bytes);
    Message message = new Message();
    message.setRaw(encodedEmail);
    return message;
  }
}


PythonThe following code sample demonstrates creating a MIME message, encoding to
a base64url string, and assigning it to the raw field of the Message
resource:


gmail/snippet/send mail/create_draft.py

View on GitHub



import base64
from email.message import EmailMessage

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_create_draft():
  """Create and insert a draft email.
   Print the returned draft's message and id.
   Returns: Draft object, including draft id and message meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    message = EmailMessage()

    message.set_content("This is automated draft mail")

    message["To"] = "gduser1@workspacesamples.dev"
    message["From"] = "gduser2@workspacesamples.dev"
    message["Subject"] = "Automated draft"

    # encoded message
    encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    create_message = {"message": {"raw": encoded_message}}
    # pylint: disable=E1101
    draft = (
        service.users()
        .drafts()
        .create(userId="me", body=create_message)
        .execute()
    )

    print(f'Draft id: {draft["id"]}\nDraft message: {draft["message"]}')

  except HttpError as error:
    print(f"An error occurred: {error}")
    draft = None

  return draft


if __name__ == "__main__":
  gmail_create_draft()



Creating messages with attachments
Creating a message with an attachment is like creating any other message,
but the process of uploading the file as a multi-part MIME
message depends on the programming language. The following code
examples demonstrate possible ways of creating a multi-part MIME message with
an attachment.

JavaThe following example shows how to create a multi-part MIME message, the
encoding and assignment steps are the same as above.


gmail/snippets/src/main/java/CreateDraftWithAttachment.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Draft;
import com.google.api.services.gmail.model.Message;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.Properties;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Session;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import org.apache.commons.codec.binary.Base64;

/* Class to demonstrate the use of Gmail Create Draft with attachment API */
public class CreateDraftWithAttachment {
  /**
   * Create a draft email with attachment.
   *
   * @param fromEmailAddress - Email address to appear in the from: header.
   * @param toEmailAddress   - Email address of the recipient.
   * @param file             - Path to the file to be attached.
   * @return the created draft, {@code null} otherwise.
   * @throws MessagingException - if a wrongly formatted address is encountered.
   * @throws IOException        - if service account credentials file not found.
   */
  public static Draft createDraftMessageWithAttachment(String fromEmailAddress,
                                                       String toEmailAddress,
                                                       File file)
      throws MessagingException, IOException {
        /* Load pre-authorized user credentials from the environment.
         TODO(developer) - See https://developers.google.com/identity for
          guides on implementing OAuth2 for your application.*/
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_COMPOSE);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    // Create the email content
    String messageSubject = "Test message";
    String bodyText = "lorem ipsum.";

    // Encode as MIME message
    Properties props = new Properties();
    Session session = Session.getDefaultInstance(props, null);
    MimeMessage email = new MimeMessage(session);
    email.setFrom(new InternetAddress(fromEmailAddress));
    email.addRecipient(javax.mail.Message.RecipientType.TO,
        new InternetAddress(toEmailAddress));
    email.setSubject(messageSubject);

    MimeBodyPart mimeBodyPart = new MimeBodyPart();
    mimeBodyPart.setContent(bodyText, "text/plain");
    Multipart multipart = new MimeMultipart();
    multipart.addBodyPart(mimeBodyPart);
    mimeBodyPart = new MimeBodyPart();
    DataSource source = new FileDataSource(file);
    mimeBodyPart.setDataHandler(new DataHandler(source));
    mimeBodyPart.setFileName(file.getName());
    multipart.addBodyPart(mimeBodyPart);
    email.setContent(multipart);

    // Encode and wrap the MIME message into a gmail message
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    email.writeTo(buffer);
    byte[] rawMessageBytes = buffer.toByteArray();
    String encodedEmail = Base64.encodeBase64URLSafeString(rawMessageBytes);
    Message message = new Message();
    message.setRaw(encodedEmail);

    try {
      // Create the draft message
      Draft draft = new Draft();
      draft.setMessage(message);
      draft = service.users().drafts().create("me", draft).execute();
      System.out.println("Draft id: " + draft.getId());
      System.out.println(draft.toPrettyString());
      return draft;
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to create draft: " + e.getDetails());
      } else {
        throw e;
      }
    }
    return null;
  }
}


PythonSimilar to the previous example, this example also handles encoding the
message to base64url and assigning it to the raw field of the Message
resource.


gmail/snippet/send mail/create_draft_with_attachment.py

View on GitHub



import base64
import mimetypes
import os
from email.message import EmailMessage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.text import MIMEText

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_create_draft_with_attachment():
  """Create and insert a draft email with attachment.
   Print the returned draft's message and id.
  Returns: Draft object, including draft id and message meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)
    mime_message = EmailMessage()

    # headers
    mime_message["To"] = "gduser1@workspacesamples.dev"
    mime_message["From"] = "gduser2@workspacesamples.dev"
    mime_message["Subject"] = "sample with attachment"

    # text
    mime_message.set_content(
        "Hi, this is automated mail with attachment.Please do not reply."
    )

    # attachment
    attachment_filename = "photo.jpg"
    # guessing the MIME type
    type_subtype, _ = mimetypes.guess_type(attachment_filename)
    maintype, subtype = type_subtype.split("/")

    with open(attachment_filename, "rb") as fp:
      attachment_data = fp.read()
    mime_message.add_attachment(attachment_data, maintype, subtype)

    encoded_message = base64.urlsafe_b64encode(mime_message.as_bytes()).decode()

    create_draft_request_body = {"message": {"raw": encoded_message}}
    # pylint: disable=E1101
    draft = (
        service.users()
        .drafts()
        .create(userId="me", body=create_draft_request_body)
        .execute()
    )
    print(f'Draft id: {draft["id"]}\nDraft message: {draft["message"]}')
  except HttpError as error:
    print(f"An error occurred: {error}")
    draft = None
  return draft


def build_file_part(file):
  """Creates a MIME part for a file.

  Args:
    file: The path to the file to be attached.

  Returns:
    A MIME part that can be attached to a message.
  """
  content_type, encoding = mimetypes.guess_type(file)

  if content_type is None or encoding is not None:
    content_type = "application/octet-stream"
  main_type, sub_type = content_type.split("/", 1)
  if main_type == "text":
    with open(file, "rb"):
      msg = MIMEText("r", _subtype=sub_type)
  elif main_type == "image":
    with open(file, "rb"):
      msg = MIMEImage("r", _subtype=sub_type)
  elif main_type == "audio":
    with open(file, "rb"):
      msg = MIMEAudio("r", _subtype=sub_type)
  else:
    with open(file, "rb"):
      msg = MIMEBase(main_type, sub_type)
      msg.set_payload(file.read())
  filename = os.path.basename(file)
  msg.add_header("Content-Disposition", "attachment", filename=filename)
  return msg


if __name__ == "__main__":
  gmail_create_draft_with_attachment()



Sending messages
Once you have created a message, you can send it by supplying it in the
request body of a call to
messages.send, as demonstrated
in the following examples.

Java


gmail/snippets/src/main/java/SendMessage.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Message;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Properties;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import org.apache.commons.codec.binary.Base64;

/* Class to demonstrate the use of Gmail Send Message API */
public class SendMessage {
  /**
   * Send an email from the user's mailbox to its recipient.
   *
   * @param fromEmailAddress - Email address to appear in the from: header
   * @param toEmailAddress   - Email address of the recipient
   * @return the sent message, {@code null} otherwise.
   * @throws MessagingException - if a wrongly formatted address is encountered.
   * @throws IOException        - if service account credentials file not found.
   */
  public static Message sendEmail(String fromEmailAddress,
                                  String toEmailAddress)
      throws MessagingException, IOException {
        /* Load pre-authorized user credentials from the environment.
           TODO(developer) - See https://developers.google.com/identity for
            guides on implementing OAuth2 for your application.*/
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SEND);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    // Create the email content
    String messageSubject = "Test message";
    String bodyText = "lorem ipsum.";

    // Encode as MIME message
    Properties props = new Properties();
    Session session = Session.getDefaultInstance(props, null);
    MimeMessage email = new MimeMessage(session);
    email.setFrom(new InternetAddress(fromEmailAddress));
    email.addRecipient(javax.mail.Message.RecipientType.TO,
        new InternetAddress(toEmailAddress));
    email.setSubject(messageSubject);
    email.setText(bodyText);

    // Encode and wrap the MIME message into a gmail message
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    email.writeTo(buffer);
    byte[] rawMessageBytes = buffer.toByteArray();
    String encodedEmail = Base64.encodeBase64URLSafeString(rawMessageBytes);
    Message message = new Message();
    message.setRaw(encodedEmail);

    try {
      // Create send message
      message = service.users().messages().send("me", message).execute();
      System.out.println("Message id: " + message.getId());
      System.out.println(message.toPrettyString());
      return message;
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to send message: " + e.getDetails());
      } else {
        throw e;
      }
    }
    return null;
  }
}


Python


gmail/snippet/send mail/send_message.py

View on GitHub



import base64
from email.message import EmailMessage

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_send_message():
  """Create and send an email message
  Print the returned  message id
  Returns: Message object, including message id

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    service = build("gmail", "v1", credentials=creds)
    message = EmailMessage()

    message.set_content("This is automated draft mail")

    message["To"] = "gduser1@workspacesamples.dev"
    message["From"] = "gduser2@workspacesamples.dev"
    message["Subject"] = "Automated draft"

    # encoded message
    encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    create_message = {"raw": encoded_message}
    # pylint: disable=E1101
    send_message = (
        service.users()
        .messages()
        .send(userId="me", body=create_message)
        .execute()
    )
    print(f'Message Id: {send_message["id"]}')
  except HttpError as error:
    print(f"An error occurred: {error}")
    send_message = None
  return send_message


if __name__ == "__main__":
  gmail_send_message()



If you're trying to send a reply and want the email to thread, make sure that:

The Subject headers match
The References and In-Reply-To headers follow the
RFC 2822 standard.

For information on sending a message from a draft, see
Creating Drafts.



The Gmail API allows you to upload file data when creating or updating a draft or when inserting or sending a message.

Upload options
The Gmail API allows you to upload certain types of binary data, or media. The specific characteristics of the data you can upload are specified on the reference page for any method that supports media uploads:

Maximum upload file size: The maximum amount of data you can store with this method.
Accepted media MIME types: The types of binary data you can store using this method.

You can make upload requests in any of the following ways. Specify the method you are using with the uploadType request parameter.

Simple upload: uploadType=media. For quick transfer of smaller files, for example, 5 MB or less.
Multipart upload: uploadType=multipart. For quick transfer of smaller files and metadata; transfers the file along with metadata that describes it, all in a single request.
Resumable upload: uploadType=resumable. For reliable transfer, especially important with larger files. With this method, you use a session initiating request, which optionally can include metadata. This is a good strategy to use for most applications, since it also works for smaller files at the cost of one additional HTTP request per upload.

When you upload media, you use a special URI. In fact, methods that support media uploads have two URI endpoints:

The /upload URI, for the media. The format of the upload endpoint is the
  standard resource URI with an “/upload” prefix. Use this URI when
    transferring the media data itself.Example: POST /upload/gmail/v1/users/userId/messages/send
The standard resource URI, for the metadata. If the resource contains any
  data fields, those fields are used to store metadata describing the uploaded
  file. You can use this URI when creating or updating metadata values.Example:
    POST /gmail/v1/users/userId/messages/send

Simple upload 
The most straightforward method for uploading a file is by making a simple upload request. This option is a good choice when:

The file is small enough to upload again in its entirety if the connection fails.
There is no metadata to send. This might be true if you plan to send metadata for this resource in a separate request, or if no metadata is supported or available.

To use simple upload, make a POST or PUT request to
the method's /upload URI and add the query parameter
uploadType=media.  For example:
POST https://www.googleapis.com/upload/gmail/v1/users/userId/messages/send?uploadType=media
The HTTP headers to use when making a simple upload request include:

Content-Type. Set to one of the method's accepted upload media data types, specified in the API reference.
Content-Length. Set to the number of bytes you are uploading. Not required if you are using chunked transfer encoding.

Example: Simple upload
The following example shows the use of a simple upload request for the
Gmail API.

POST /upload/gmail/v1/users/userId/messages/send?uploadType=media HTTP/1.1
Host: www.googleapis.com
Content-Type: message/rfc822
Content-Length: number_of_bytes_in_file
Authorization: Bearer your_auth_token

Email Message data
If the request succeeds, the server returns the HTTP 200 OK status code along with any metadata:
HTTP/1.1 200
Content-Type: application/json

{  "id": string,  "threadId": string,  "labelIds": [    string  ],  "snippet": string,  "historyId": unsigned long,  "payload": {    "partId": string,    "mimeType": string,    "filename": string,    "headers": [      {        "name": string,        "value": string      }    ],    "body": users.messages.attachments Resource,    "parts": [      (MessagePart)    ]  },  "sizeEstimate": integer,  "raw": bytes}
Multipart upload
If you have metadata that you want to send along with the data to upload, you can make a single multipart/related request. This is a good choice if the data you are sending is small enough to upload again in its entirety if the connection fails.
To use multipart upload, make a POST or PUT request to the method's /upload URI and add the query parameter
uploadType=multipart, for example:

POST https://www.googleapis.com/upload/gmail/v1/users/userId/messages/send?uploadType=multipart
The top-level HTTP headers to use when making a multipart upload request include:

Content-Type. Set to multipart/related and include the boundary string you're using to identify the parts of the request.
Content-Length. Set to the total number of bytes in the request body. The media portion of the request must be less than the maximum file size specified for this method.

The body of the request is formatted as a multipart/related content type [RFC2387] and contains exactly two parts. The parts are identified by a boundary string, and the final boundary string is followed by two hyphens.
Each part of the multipart request needs an additional Content-Type header:

Metadata part: Must come first, and Content-Type must match one of the accepted metadata formats.
Media part: Must come second, and Content-Type must match one the method's accepted media MIME types.

See the API reference for each method's list of accepted media MIME types and size limits for uploaded files.
Note: To create or update the metadata portion
only, without uploading the associated data, simply send a POST or PUT request to the standard resource endpoint:
https://www.googleapis.com/gmail/v1/users/userId/messages/send
Example: Multipart upload
The example below shows a multipart upload request for the Gmail API.
POST /upload/gmail/v1/users/userId/messages/send?uploadType=multipart HTTP/1.1
Host: www.googleapis.com
Authorization: Bearer your_auth_token
Content-Type: multipart/related; boundary=foo_bar_baz
Content-Length: number_of_bytes_in_entire_request_body

--foo_bar_baz
Content-Type: application/json; charset=UTF-8

{  "id": string,  "threadId": string,  "labelIds": [    string  ],  "snippet": string,  "historyId": unsigned long,  "payload": {    "partId": string,    "mimeType": string,    "filename": string,    "headers": [      {        "name": string,        "value": string      }    ],    "body": users.messages.attachments Resource,    "parts": [      (MessagePart)    ]  },  "sizeEstimate": integer,  "raw": bytes}

--foo_bar_baz
Content-Type: message/rfc822

Email Message data
--foo_bar_baz--
If the request succeeds, the server returns the HTTP 200 OK status code along with any metadata:
HTTP/1.1 200
Content-Type: application/json

{  "id": string,  "threadId": string,  "labelIds": [    string  ],  "snippet": string,  "historyId": unsigned long,  "payload": {    "partId": string,    "mimeType": string,    "filename": string,    "headers": [      {        "name": string,        "value": string      }    ],    "body": users.messages.attachments Resource,    "parts": [      (MessagePart)    ]  },  "sizeEstimate": integer,  "raw": bytes}
Resumable upload
To upload data files more reliably, you can use the resumable upload protocol. This protocol allows you to resume an upload operation after a communication failure has interrupted the flow of data. It is especially useful if you are transferring large files and the likelihood of a network interruption or some other transmission failure is high, for example, when uploading from a mobile client app. It can also reduce your bandwidth usage in the event of network failures because you don't have to restart large file uploads from the beginning.
The steps for using resumable upload include:

Start a resumable session. Make an initial request to the upload URI that includes the metadata, if any.
Save the resumable session URI. Save the session URI returned in the response of the initial request; you'll use it for the remaining requests in this session.
Upload the file. Send the media file to the resumable session URI.

In addition, apps that use resumable upload need to have code to resume an interrupted upload. If an upload is interrupted, find out how much data was successfully received, and then resume the upload starting from that point.
Note: An upload URI expires after one week.

Step 1: Start a resumable session
To initiate a resumable upload, make a POST or PUT request to the method's /upload URI and add the query parameter
uploadType=resumable, for example:

POST https://www.googleapis.com/upload/gmail/v1/users/userId/messages/send?uploadType=resumable
For this initiating request, the body is either empty or it contains the metadata only; you'll transfer the actual contents of the file you want to upload in subsequent requests.

Use the following HTTP headers with the initial request:


X-Upload-Content-Type. Set to the media MIME type of the upload data to be transferred in subsequent requests.
X-Upload-Content-Length. Set to the number of bytes of upload data to be transferred in subsequent requests.  If the length is unknown at the time of this request, you can omit this header.
If providing metadata: Content-Type. Set according to the metadata's data type.
Content-Length. Set to the number of bytes provided in the body of this initial request. Not required if you are using chunked transfer encoding.

See the API reference for each method's list of accepted media MIME types and size limits for uploaded files.
Example: Resumable session initiation request
The following example shows how to initiate a resumable session for the Gmail API.
POST /upload/gmail/v1/users/userId/messages/send?uploadType=resumable HTTP/1.1
Host: www.googleapis.com
Authorization: Bearer your_auth_token
Content-Length: 38
Content-Type: application/json; charset=UTF-8
X-Upload-Content-Type: message/rfc822
X-Upload-Content-Length: 2000000

{  "id": string,  "threadId": string,  "labelIds": [    string  ],  "snippet": string,  "historyId": unsigned long,  "payload": {    "partId": string,    "mimeType": string,    "filename": string,    "headers": [      {        "name": string,        "value": string      }    ],    "body": users.messages.attachments Resource,    "parts": [      (MessagePart)    ]  },  "sizeEstimate": integer,  "raw": bytes}
Note: For an initial resumable update request without metadata, leave the body of the request empty, and set the Content-Length header to 0.
The next section describes how to handle the response.
Step 2: Save the resumable session URI
If the session initiation request succeeds, the API server responds with a 200 OK HTTP status code. In addition, it provides a Location header that specifies your resumable session URI. The Location header, shown in the example below, includes an upload_id query parameter portion that gives the unique upload ID to use for this session.
Example: Resumable session initiation response
Here is the response to the request in Step 1:

HTTP/1.1 200 OK
Location: https://www.googleapis.com/upload/gmail/v1/users/userId/messages/send?uploadType=resumable&upload_id=xa298sd_sdlkj2
Content-Length: 0
The value of the Location header, as shown in the above example response, is the session URI you'll use as the HTTP endpoint for doing the actual file upload or querying the upload status.
Copy and save the session URI so you can use it for subsequent requests.
Step 3: Upload the file
To upload the file, send a PUT request to the upload URI that you obtained in the previous step. The format of the upload request is:

PUT session_uri

The HTTP headers to use when making the resumable file upload requests includes Content-Length. Set this to the number of bytes you are uploading in this request, which is generally the upload file size.
Example: Resumable file upload request
Here is a resumable request to upload the entire 2,000,000 byte Email Message file for the current example.

PUT https://www.googleapis.com/upload/gmail/v1/users/userId/messages/send?uploadType=resumable&upload_id=xa298sd_sdlkj2 HTTP/1.1
Content-Length: 2000000
Content-Type: message/rfc822

bytes 0-1999999
If the request succeeds, the server responds with an HTTP 201 Created, along with any metadata associated with this resource. If the initial request of the resumable session had been a PUT, to update an existing resource, the success response would be  200 OK, along with any metadata associated with this resource.
If the upload request is interrupted or if you receive an HTTP 503 Service Unavailable or any other 5xx response from the server, follow the procedure outlined in resume an interrupted upload.  

Uploading the file in chunks
With resumable uploads, you can break a file into chunks and send a series of requests to upload each chunk in sequence. This is not the preferred approach since there are performance costs associated with the additional requests, and it is generally not needed. However, you might need to use chunking to reduce the amount of data transferred in any single request. This is helpful when there is a fixed time limit for individual requests, as is true for certain classes of Google App Engine requests. It also lets you do things like providing upload progress indications for legacy browsers that don't have upload progress support by default.

Expand for more info
If you are uploading the data in chunks, the Content-Range header is also required, along with the Content-Length header required for full file uploads:

Content-Length. Set to the chunk size or possibly less, as might be the case for the last request.
Content-Range: Set to show which bytes in the file you are uploading.  For example, Content-Range: bytes 0-524287/2000000 shows that you are providing the first 524,288 bytes (256 x 1024 x 2) in a 2,000,000 byte file.

 Chunk size restriction: All chunks must be a multiple of 256 KB (256 x 1024 bytes) in size, except for the final chunk that completes the upload. If you use chunking, it is important to keep the chunk size as large as possible to keep the upload efficient.
Example: Resumable chunked file upload request
A request that sends the first 524,288 bytes might look like this:
PUT {session_uri} HTTP/1.1
Host: www.googleapis.com
Content-Length: 524288
Content-Type: message/rfc822
Content-Range: bytes 0-524287/2000000

bytes 0-524288
If the request succeeds, the server responds with 308 Resume Incomplete, along with a Range header that identifies the total number of bytes that have been stored so far:

HTTP/1.1 308 Resume Incomplete
Content-Length: 0
Range: bytes=0-524287
Use the upper value returned in the Range header to determine where to start the next chunk. Continue to PUT each chunk of the file until the entire file has been uploaded.
If any chunk's PUT request is interrupted or if you receive an HTTP 503 Service Unavailable or any other 5xx response from the server, follow the procedure outlined in resume an interrupted upload, but instead of uploading the rest of the file, simply continue uploading chunks from that point.
Important Notes:

Be sure to use the Range header in the response to determine where to start the next chunk; do not assume that the server received all bytes sent in the previous request.
Each upload URI has a finite lifetime and eventually expires (within a day or so, if not used). For this reason, it is best to start a resumable upload as soon as you obtain the upload URI, and to resume an interrupted upload shortly after the interruption occurred.
If you send a request with an expired upload session ID, the server returns a 404 Not Found status code. When an unrecoverable error occurs in the upload session, the server returns a 410 Gone status code. In these cases, you must start a new resumable upload, obtain a new upload URI, and start the upload from the beginning using the new endpoint.

When the entire file upload is complete, the server responds with an HTTP 201 Created along with any metadata associated with this resource. If this request had been updating an existing entity rather than creating a new one, the HTTP response code for a completed upload would have been 200 OK.


Resume an interrupted upload
If an upload request is terminated before receiving a response or if you receive an HTTP 503 Service Unavailable response from the server, then you need to resume the interrupted upload. To do this:

Request status. Query the current status of the upload by issuing an empty PUT request to the upload URI. For this request, the HTTP headers should include a Content-Range header indicating that the current position in the file is unknown.  For example, set the Content-Range to */2000000 if your total file length is 2,000,000. If you don't know the full size of the file, set the Content-Range to */*.
Note: You can request the status between chunks, not just if the upload is interrupted. This is useful, for example, if you want to show upload progress indications for legacy browsers.
Get number of bytes uploaded. Process the response from the status query. The server uses the Range header in its response to specify which bytes it has received so far.  For example, a Range header of 0-299999 indicates that the first 300,000 bytes of the file have been received.
Upload remaining data. Finally, now that you know where to resume the request, send the remaining data or current chunk. Note that you need to treat the remaining data as a separate chunk in either case, so you need to send the Content-Range header when you resume the upload.

Example: Resuming an interrupted upload
1) Request the upload status.
The following request uses the Content-Range header to indicate that the current position in the 2,000,000 byte file is unknown.

PUT {session_uri} HTTP/1.1
Content-Length: 0
Content-Range: bytes */2000000
2) Extract the number of bytes uploaded so far from the response.
The server's response uses the Range header to indicate that it has received the first 43 bytes of the file so far. Use the upper value of the Range header to determine where to start the resumed upload.
HTTP/1.1 308 Resume Incomplete
Content-Length: 0
Range: 0-42
Note: It is possible that the status response could be 201 Created or 200 OK if the upload is complete. This could happen if the connection broke after all bytes were uploaded but before the client received a response from the server.
3) Resume the upload from the point where it left off.
The following request resumes the upload by sending the remaining bytes of the file, starting at byte 43.

PUT {session_uri} HTTP/1.1
Content-Length: 1999957
Content-Range: bytes 43-1999999/2000000

bytes 43-1999999
Best practices
When uploading media, it is helpful to be aware of some best practices related to error handling.

Resume or retry uploads that fail due to connection interruptions or any 5xx errors, including:
  
500 Internal Server Error
502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout

Use an exponential backoff strategy if any 5xx server error is returned when resuming or retrying upload requests. These errors can occur if a server is getting overloaded. Exponential backoff can help alleviate these kinds of problems during periods of high volume of requests or heavy network traffic.
Other kinds of requests should not be handled by exponential backoff but you can still retry a number of them. When retrying these requests, limit the number of times you retry them. For example your code could limit to ten retries or less before reporting an error.
Handle 404 Not Found and 410 Gone errors when doing resumable uploads by starting the entire upload over from the beginning.


Exponential backoff
Exponential backoff is a standard error handling strategy for network applications in which the client periodically retries a failed request over an increasing amount of time. If a high volume of requests or heavy network traffic causes the server to return errors, exponential backoff may be a good strategy for handling those errors. Conversely, it is not a relevant strategy for dealing with errors unrelated to network volume or response times, such as invalid authorization credentials or file not found errors.
Used properly, exponential backoff increases the efficiency of bandwidth usage, reduces the number of requests required to get a successful response, and maximizes the throughput of requests in concurrent environments.
The flow for implementing simple exponential backoff is as follows:


Make a request to the API.
Receive an HTTP 503 response, which indicates you should retry the request.
Wait 1 second + random_number_milliseconds and retry the request.
Receive an HTTP 503 response, which indicates you should retry the request.
Wait 2 seconds + random_number_milliseconds, and retry the request.
Receive an HTTP 503 response, which indicates you should retry the request.
Wait 4 seconds + random_number_milliseconds, and retry the request.
Receive an HTTP 503 response, which indicates you should retry the request.
Wait 8 seconds + random_number_milliseconds, and retry the request.
Receive an HTTP 503 response, which indicates you should retry the request.
Wait 16 seconds + random_number_milliseconds, and retry the request.
Stop. Report or log an error.

In the above flow, random_number_milliseconds is a random number of milliseconds less than or equal to 1000. This is necessary, since introducing a small random delay helps distribute the load more evenly and avoid the possibility of stampeding the server. The value of random_number_milliseconds must be redefined after each wait.
Note: The wait is always (2 ^ n) + random_number_milliseconds, where n is a monotonically increasing integer initially defined as 0. The integer n is incremented by 1 for each iteration (each request).

The algorithm is set to terminate when n is 5. This ceiling prevents clients from retrying infinitely, and results in a total delay of around 32 seconds before a request is deemed "an unrecoverable error." A larger maximum number of retries is fine, especially if a long upload is in progress; just be sure to cap the retry delay at something reasonable, say, less than one minute.
API client library guides

.NET
Java
PHP
Python
Ruby



The Gmail API uses Thread resources
to group email replies with their original message into a single conversation or
thread. This allows you to retrieve all messages in a conversation, in order,
making it easier to have context for a message or to refine search results.
Like messages, threads may also have
labels applied to them. However, unlike messages, threads cannot be created,
only deleted. Messages can, however, be inserted into a thread.
Contents
Retrieving threads
Threads provide a simple way of retrieving messages in a conversation in order.
By listing a set of threads you can choose to group messages by conversation
and provide additional context. You can retrieve a list of threads using the
threads.list method, or retrieve
a specific thread with
threads.get. You can also
filter threads using the same query parameters as
for the Message resource. If any
message in a thread matches the query, that thread is returned in the result.




The code sample below demonstrates how to use both methods in a sample that
displays the most chatty threads in your inbox.  The threads.list method
fetches all thread IDs, then threads.get grabs all messages in each thread.
For those with 3 or more replies, we extract the Subject line and display the
non-empty ones plus the number of messages in the thread. You'll also find this
code sample featured in the corresponding DevByte video.


Python


gmail/snippet/thread/threads.py

View on GitHub



import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def show_chatty_threads():
  """Display threads with long conversations(>= 3 messages)
  Return: None

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    # pylint: disable=maybe-no-member
    # pylint: disable:R1710
    threads = (
        service.users().threads().list(userId="me").execute().get("threads", [])
    )
    for thread in threads:
      tdata = (
          service.users().threads().get(userId="me", id=thread["id"]).execute()
      )
      nmsgs = len(tdata["messages"])

      # skip if <3 msgs in thread
      if nmsgs > 2:
        msg = tdata["messages"][0]["payload"]
        subject = ""
        for header in msg["headers"]:
          if header["name"] == "Subject":
            subject = header["value"]
            break
        if subject:  # skip if no Subject line
          print(f"- {subject}, {nmsgs}")
    return threads

  except HttpError as error:
    print(f"An error occurred: {error}")


if __name__ == "__main__":
  show_chatty_threads()



Adding drafts and messages to threads
If you are sending or migrating messages that are a response to another email
or part of a conversation, your application should add that message to the
related thread. This makes it easier for Gmail users who are participating in
the conversation to keep the message in context.
A draft can be added to a thread as part of
creating,
updating, or
sending a draft message.
You can also add a message to a thread as part of
inserting or
sending a message.
In order to be part of a thread, a message or draft must meet the following
criteria:

The requested threadId must be specified on the Message or
Draft.Message you supply with your request.
The References and In-Reply-To headers must be set in compliance with the
RFC 2822 standard.
The Subject headers must match.

Take a look at the creating a draft or sending a
message examples. In both cases, you would simply
add a threadId key paired with a thread ID to a message's metadata, the
message object.


You can use labels to tag, organize, and categorize messages and threads
in Gmail. A label has a many-to-many relationship with messages and
threads: you can apply multiple labels to a single message or thread
and apply a single label to multiple messages or threads.
For information about how to
create,
get,
list,
update,
or delete labels, see the
Labels reference.
To manage labels, you must use the
https://www.googleapis.com/auth/gmail.labels scope. For more information
about scopes, see
Gmail API-specific authorization and authentication information.
Types of labels
Labels come in two varieties: reserved SYSTEM labels and custom USER labels.
System labels typically correspond to pre-defined elements in the Gmail web
interface such as the inbox. Systems label names are reserved; no USER label can
be created with the same name as any SYSTEM label. The following table lists
several of the most common Gmail system labels:


Name
Can be manually applied
Notes



INBOX
yes



SPAM
yes



TRASH
yes



UNREAD
yes



STARRED
yes



IMPORTANT
yes



SENT
no
Applied automatically to messages that are sent with
      drafts.send or
      messages.send, inserted
      with messages.insert
      and the user's email in the From header, or sent by the user through
      the web interface.


DRAFT
no
Automatically applied to all
      draft messages created with the
      Gmail API or Gmail interface.


CATEGORY_PERSONAL
yes
Corresponds to messages that are displayed in the Personal tab of
      the Gmail interface.


CATEGORY_SOCIAL
yes
Corresponds to messages that are displayed in the Social tab of the
      Gmail interface.


CATEGORY_PROMOTIONS
yes
Corresponds to messages that are displayed in the Promotions tab of
      the Gmail interface.


CATEGORY_UPDATES
yes
Corresponds to messages that are displayed in the Updates tab of the
      Gmail interface.


CATEGORY_FORUMS
yes
Corresponds to messages that are displayed in the Forums tab of the
      Gmail interface.



Note: The above list is not exhaustive and other reserved label names exist.
Attempting to create a custom label with a name that conflicts with a reserved
name results in an HTTP 400 - Invalid label name error.
Manage labels on messages & threads
Labels only exist on messages. For instance, if you list labels on a thread, you
get a list of labels that exist on any of the messages within the thread. A
label might not exist on every message within a thread. You can apply
multiple labels to messages, but you can't apply
labels to draft messages.
Add or remove labels to threads
When you add or remove a label to a thread, you add or remove the specified
label on all existing messages in the thread.
If messages are added to a thread after you add a label, the new messages
don't inherit the existing label associated with the thread. To add the label
to those messages, add the label to the thread again.
To add or remove the labels associated with a thread, use
threads.modify.
Add or remove labels to messages
When you add a label to a message, the label is added to that message and
becomes associated with the thread to which the message belongs. The label isn't
added to other messages within the thread.
If you remove a label from a message and it was the only message in the thread
with that label, the label is also removed from the thread.
To add or remove the labels applied to a message, use
messages.modify.


You can search or filter files using the
messages.list and
threads.list methods.
These methods accept the q parameter which supports most of the same
advanced search syntax as
the Gmail web-interface. For a list of search and filter differences between
the Gmail UI and Gmail API, see
Search filter differences: Gmail UI versus Gmail API.
This advanced syntax allows you to use search queries
to filter messages by properties such as the sender, date, or label to name a
few possibilities. For example, the following query retrieves all messages sent
by the user in January of 2014:
GET https://www.googleapis.com/gmail/v1/users/me/messages?q=in:sent after:2014/01/01 before:2014/02/01
Warning: All dates used in the search query are interpreted as midnight on that
date in the PST timezone. To specify accurate dates for other timezones pass the
value in seconds instead:
?q=in:sent after:1388552400 before:1391230800
In addition to search queries, you can also filter messages and threads by label
with the labelIds parameter. This allows you to search for messages and
threads with the specified system or user labels applied. For more information,
see the messages.list or
threads.list method reference.
Search and filter differences: Gmail UI versus Gmail API

The Gmail UI performs alias expansion which allows it to infer an
account alias from a Google Workspace account. For example, suppose you have an
account
of myprimary@mycompany.net and your admin sets up an alias for that account of
myalias@mycompany.net. If myalias@mycompany.net sends an email, but you
search for "from: myprimary@mycompany.net)" the email sent by
myalias@mycompany.net shows up as a search result the Gmail UI, but not in
the API response.
The Gmail UI allows users to perform thread-wide searches, but the API
doesn't.



Keeping your client synchronized with Gmail is important for most application
scenarios. There are two overall synchronization scenarios: full synchronization
and partial synchronization. Full synchronization is required the first time
your client connects to Gmail and in some other rare scenarios. If your client
has recently synchronized, partial synchronization is a lighter-weight
alternative to a full sync.  You can also use push notifications
to trigger partial synchronization in real-time and only when necessary, thereby
avoiding needless polling.
Contents

Full synchronization
The first time your application connects to Gmail, or if partial synchronization
is not available, you must perform a full sync. In a full sync operation, your
application should retrieve and store as many of the most recent messages or
threads as are necessary for your purpose. For example, if your application
displays a list of recent messages, you may wish to retrieve and cache enough
messages to allow for a responsive interface if the user scrolls beyond the
first several messages displayed. The general procedure for performing a full
sync operation is as follows:

Call messages.list to
retrieve the first page of message IDs.
Create a batch request of
messages.get requests for each
of the messages returned by the list request. If your application displays
message contents, you should use format=FULL or format=RAW the first time
your application retrieves a message and cache the results to avoid additional
retrieval operations. If you are retrieving a previously cached message, you
should use format=MINIMAL to reduce the size of the response as only the
labelIds may change.
Merge the updates into your cached results. Your application should store
the historyId of the most recent message (the first message in the list
response) for future partial synchronization.

Note: You can also perform synchronization using the equivalent
Threads resource methods. This may
be advantageous if your application primarily works with threads or only
requires message metadata.

Partial synchronization
If your application has synchronized recently, you can perform a partial
sync using the history.list
method to return all history records newer than the startHistoryId you specify
in your request. History records provide message IDs and type of change for
each message, such as message added, deleted, or labels modified since the time
of the startHistoryId. You can obtain and store the historyId of the most
recent message from a full or partial sync to provide as a startHistoryId for
future partial synchronization operations.

Limitations
History records are typically available for at least one week and often
longer. However, the time period for which records are available may be
significantly less and records may sometimes be unavailable in rare cases. If
the startHistoryId supplied by your client is outside the available range of
history records, the API returns an HTTP 404 error response. In this case,
your client must perform a full sync as described in the previous section.


Overview
The Gmail API provides server push notifications that let you watch for
changes to Gmail mailboxes. You can use this feature to improve the performance
of your application. It allows you to eliminate the extra network and compute
costs involved with polling resources to determine if they have changed.
Whenever a mailbox changes, the Gmail API notifies your backend
server application.
Note: For notifications to user-owned devices
(i.e. installed apps, mobile devices, or browsers), the poll-based
sync guide is still the recommended approach to retrieve
updates.

Initial Cloud Pub/Sub Setup
The Gmail API uses the Cloud Pub/Sub API to deliver
push notifications.  This allows notification via a variety of methods
including webhooks and polling on a single subscription endpoint.
Prerequisites
In order to complete the rest of this setup, make sure you fulfill the
Cloud Pub/Sub Prerequisites and then
set up a Cloud Pub/Sub client.
Create a topic
Using your Cloud Pub/Sub client, create the topic
that the Gmail API should
send notifications to.  The topic name can be any name you choose under your
project (i.e. matching projects/myproject/topics/*, where myproject
is the Project ID listed for your project in the Google Developers Console).
We recommend that you use a single topic for all Gmail API push notifications
for your application, due to Cloud Pub/Sub limits
on the number of topics.
Create a subscription
Follow the
Cloud Pub/Sub Subscriber Guide to set up
a subscription to the topic that you created. Configure the subscription type to
be either a webhook push (i.e. HTTP POST callback) or pull (i.e. initiated by
your app). This is how your application will receive notifications for updates.

Grant publish rights on your topic
Cloud Pub/Sub requires that you grant Gmail privileges to publish notifications
to your topic.
To do this, you need to grant publish privileges to
gmail-api-push@system.gserviceaccount.com. You can do this
using the Cloud Pub/Sub Developer Console permissions interface
following the resource-level access control instructions.

Getting Gmail mailbox updates
Once the initial Cloud Pub/Sub setup is finished, configure Gmail accounts to
send notifications for mailbox updates.
Watch request
To configure Gmail accounts to send notifications to your Cloud Pub/Sub topic,
simply use your Gmail API client to call
watch
on the Gmail user mailbox similar to any other Gmail API call.
To do so, provide the topic name created above and any other options
in your watch request, such as labels to
filter on. For example, to be notified any time a change is made to the Inbox:

ProtocolPOST "https://www.googleapis.com/gmail/v1/users/me/watch"
Content-type: application/json

{
  topicName: "projects/myproject/topics/mytopic",
  labelIds: ["INBOX"],
  labelFilterBehavior: "INCLUDE",
}

Pythonrequest = {
  'labelIds': ['INBOX'],
  'topicName': 'projects/myproject/topics/mytopic',
  'labelFilterBehavior': 'INCLUDE'
}
gmail.users().watch(userId='me', body=request).execute()


Watch response
If the watch request is successful
you will receive a response like:
{
  historyId: 1234567890
  expiration: 1431990098200
}

with the current mailbox historyId for the user.  All changes after that
historyId will be notified to your client.  If you need to process changes
prior to this historyId, refer to the sync guide.
Additionally, a successful watch call should cause a notification to
immediately be sent to your Cloud Pub/Sub topic.
If you receive an error from the watch call, the details should explain
the source of the problem, which is typically with the setup of the
Cloud Pub/Sub topic and subscription.  Refer to the
Cloud Pub/Sub documentation to confirm that
the setup is correct and for help with debugging topic and subscription issues.
Renewing mailbox watch
You must re-call watch at least every
7 days or else you will stop receiving updates for the user.  We recommend
calling watch once per day.  The watch response also has an expiration
field with the timestamp for the watch expiration.
Receiving notifications
Whenever a mailbox update occurs that matches your watch, your application
will receive a notification message describing the change.
If you have configured a push subscription, a webhook notification to your
server will conform to a
PubsubMessage:
POST https://yourserver.example.com/yourUrl
Content-type: application/json

{
  message:
  {
    // This is the actual notification data, as base64url-encoded JSON.
    data: "eyJlbWFpbEFkZHJlc3MiOiAidXNlckBleGFtcGxlLmNvbSIsICJoaXN0b3J5SWQiOiAiMTIzNDU2Nzg5MCJ9",

    // This is a Cloud Pub/Sub message id, unrelated to Gmail messages.
    "messageId": "2070443601311540",

    // This is the publish time of the message.
    "publishTime": "2021-02-26T19:13:55.749Z",
  }

  subscription: "projects/myproject/subscriptions/mysubscription"
}

The HTTP POST body is JSON and the actual Gmail notification payload is in the
message.data field.  That message.data field is a base64url-encoded string
that decodes to a JSON object containing the email address and the new mailbox
history ID for the user:
{"emailAddress": "user@example.com", "historyId": "9876543210"}

You can then use history.list
to get the change details for the user since their last known
historyId, as per the sync guide.
If you have configured a pull subscription instead, refer to the code samples in
the Cloud Pub/Sub Subscriber Pull Guide for
more details on receiving messages.
Responding to notifications
All notifications need to be acknowledged. If you use webhook
push delivery, then responding
successfully (e.g. HTTP 200) will acknowledge the notification.
If using pull delivery
(REST Pull,
RPC Pull
, or
RPC StreamingPull)
then you must follow up with an acknowledge call
(REST
or
RPC).
Refer to the code samples in the
Cloud Pub/Sub Subscriber Pull Guide for
more details on acknowledging messages either
asynchronously or
synchronously using the
official RPC-based client libraries.
If the notifications are not acknowledged (e.g. your webhook callback
returns an error or times out), Cloud Pub/Sub will retry the notification
at a later time.

Stopping mailbox updates
To stop receiving updates on a mailbox, call
stop and all new notifications
should stop within a few minutes.

Limitations
Max notification rate
Each Gmail user being watched has a maximum notification rate of 1 event/sec. Any
user notifications above that rate will be dropped.  Be careful when handling
notifications to be sure not to trigger another notification, and thereby
start a notification loop.
Reliability
Typically all notifications should be delivered reliably within a few seconds;
however in some extreme situations notifications may be delayed or dropped.
Make sure to handle this possibility gracefully, so that the application
still syncs even if no push messages are received.  For example, fall back to
periodically calling
history.list after a
period with no notifications for a user.
Cloud Pub/Sub Limitations
The Cloud Pub/Sub API also has its own limitations, specifically detailed
in its pricing and quotas documentation.






Send-as aliases represent the email addresses an account can
send mail from. Each account always has at least one alias to represent the
primary email address of the account.
Send-as aliases correspond to the
"Send mail as" feature in the
web interface.
Aliases are also used to manage signatures for an account. Basic understanding
of send-as aliases are required for you to be able to change email signatures.
The above video shows you how to loop through send-as aliases and modify the
signature for a user's primary email address.
For information about how to
create,
list,
get,
update,
or delete aliases,
see the
SendAs reference.
Creating and verifying aliases
You must create
aliases prior to use. In some cases, users must also verify ownership of the
alias.
If Gmail requires user verification for an alias, the alias is returned with the
status pending. A verification message is automatically sent to the
target email address. The owner of the email address must complete the verification
process before it can be used.
Aliases that do not require verification have a verification status of accepted.
Use the verify method to
resend the verification request if needed.
SMTP settings
Aliases for external addresses should send mail through a remote SMTP
mail sending agent (MSA). To configure the SMTP MSA for an alias, use
the smtpMsa field to provide the connection details.
Managing signatures
You may also configure email signatures for each alias.  For example, to set the
signature for the user's primary address:

Java


gmail/snippets/src/main/java/UpdateSignature.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.ListSendAsResponse;
import com.google.api.services.gmail.model.SendAs;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;

/* Class to demonstrate the use of Gmail Update Signature API */
public class UpdateSignature {
  /**
   * Update the gmail signature.
   *
   * @return the updated signature id , {@code null} otherwise.
   * @throws IOException - if service account credentials file not found.
   */
  public static String updateGmailSignature() throws IOException {
        /* Load pre-authorized user credentials from the environment.
           TODO(developer) - See https://developers.google.com/identity for
            guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SETTINGS_BASIC);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    try {
      SendAs primaryAlias = null;
      ListSendAsResponse aliases = service.users().settings().sendAs().list("me").execute();
      for (SendAs alias : aliases.getSendAs()) {
        if (alias.getIsPrimary()) {
          primaryAlias = alias;
          break;
        }
      }
      // Updating a new signature
      SendAs aliasSettings = new SendAs().setSignature("Automated Signature");
      SendAs result = service.users().settings().sendAs().patch(
              "me",
              primaryAlias.getSendAsEmail(),
              aliasSettings)
          .execute();
      //Prints the updated signature
      System.out.println("Updated signature - " + result.getSignature());
      return result.getSignature();
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to update signature: " + e.getDetails());
      } else {
        throw e;
      }
    }
    return null;
  }
}


Python


gmail/snippet/settings snippets/update_signature.py

View on GitHub



import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def update_signature():
  """Create and update signature in gmail.
  Returns:Draft object, including updated signature.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    primary_alias = None

    # pylint: disable=E1101
    aliases = service.users().settings().sendAs().list(userId="me").execute()
    for alias in aliases.get("sendAs"):
      if alias.get("isPrimary"):
        primary_alias = alias
        break

    send_as_configuration = {
        "displayName": primary_alias.get("sendAsEmail"),
        "signature": "Automated Signature",
    }

    # pylint: disable=E1101
    result = (
        service.users()
        .settings()
        .sendAs()
        .patch(
            userId="me",
            sendAsEmail=primary_alias.get("sendAsEmail"),
            body=send_as_configuration,
        )
        .execute()
    )
    print(f'Updated signature for: {result.get("displayName")}')

  except HttpError as error:
    print(f"An error occurred: {error}")
    result = None

  return result.get("signature")


if __name__ == "__main__":
  update_signature()





You can use Settings to
configure forwarding for an account. To be used as a forwarding email address,
an address must fulfill one of the following criteria:

The email address has been verified. For further information, see
Creating and verifying forwarding addresses
The email address belongs to the same domain as the sender.
The email address belongs to a subdomain within the same domain of the sender.
The email address belongs to a domain alias configured as part of the same
Google Workspace account.

If the forwarding email address doesn't adhere to one of these rules, setting up
forwarding using the API fails.
For information on how to
create,
list,
get,
or delete
forwarding addresses,
see the ForwardingAddresses reference.
For information on how to get or
update forwarding
settings, see the Settings reference
Creating and verifying forwarding addresses
You must create
forwarding addresses prior to use. In some cases, users must also verify ownership of the
address as well.
If Gmail requires user verification for a forwarding address, the address is returned with the
status pending. A verification message is automatically sent to the
target email address. The owner of the email address must complete the verification
process before it can be used.
Forwarding addresses that do not require verification have a verification status of accepted.
Enabling auto-forwarding
Call the updateAutoForwarding
method to enable auto-forwarding for an account. The call requires both a registered
and verified forwarding address as well as an action to take on forwarded messages.
For example, to enable auto-forwarding and move forwarded messages to the trash:

Java


gmail/snippets/src/main/java/EnableForwarding.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.AutoForwarding;
import com.google.api.services.gmail.model.ForwardingAddress;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;

/* Class to demonstrate the use of Gmail Enable Forwarding API */
public class EnableForwarding {
  /**
   * Enable the auto-forwarding for an account.
   *
   * @param forwardingEmail - Email address of the recipient whose email will be forwarded.
   * @return forwarding id and metadata, {@code null} otherwise.
   * @throws IOException - if service account credentials file not found.
   */
  public static AutoForwarding enableAutoForwarding(String forwardingEmail) throws IOException {
        /* Load pre-authorized user credentials from the environment.
           TODO(developer) - See https://developers.google.com/identity for
            guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SETTINGS_SHARING);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    try {
      // Enable auto-forwarding and move forwarded messages to the trash
      ForwardingAddress address = new ForwardingAddress()
          .setForwardingEmail(forwardingEmail);
      ForwardingAddress createAddressResult = service.users().settings().forwardingAddresses()
          .create("me", address).execute();
      if (createAddressResult.getVerificationStatus().equals("accepted")) {
        AutoForwarding autoForwarding = new AutoForwarding()
            .setEnabled(true)
            .setEmailAddress(address.getForwardingEmail())
            .setDisposition("trash");
        autoForwarding =
            service.users().settings().updateAutoForwarding("me", autoForwarding).execute();
        System.out.println(autoForwarding.toPrettyString());
        return autoForwarding;
      }
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to enable forwarding: " + e.getDetails());
      } else {
        throw e;
      }
    }
    return null;
  }
}


Python


gmail/snippet/settings snippets/enable_forwarding.py

View on GitHub



import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def enable_forwarding():
  """Enable email forwarding.
  Returns:Draft object, including forwarding id and result meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    address = {"forwardingEmail": "gduser1@workspacesamples.dev"}

    # pylint: disable=E1101
    result = (
        service.users()
        .settings()
        .forwardingAddresses()
        .create(userId="me", body=address)
        .execute()
    )
    if result.get("verificationStatus") == "accepted":
      body = {
          "emailAddress": result.get("forwardingEmail"),
          "enabled": True,
          "disposition": "trash",
      }
      # pylint: disable=E1101
      result = (
          service.users()
          .settings()
          .updateAutoForwarding(userId="me", body=body)
          .execute()
      )
      print(f"Forwarding is enabled : {result}")

  except HttpError as error:
    print(f"An error occurred: {error}")
    result = None

  return result


if __name__ == "__main__":
  enable_forwarding()



To disable autoforwarding, call updateAutoForwarding
and set the enabled property to false.
Forwarding specific messages
Auto-forwarding sends all received messages to the target account. To
selectively forward messages, use filters
to create rules that forward in response to message attributes or content.


You can use Filters to
configure advanced filtering rules for an account. Filters can automatically
add or remove labels or forward emails to
verified aliases based on the
attributes or content of the incoming message.
For information on how to
create,
list,
get,
or delete filters,
see the Filters reference.
Matching criteria
You can filter messages by properties such as the sender, subject date, size,
and message contents. Any query using Gmail's
advanced search syntax
can also be used in a filter. For example, common filter patterns include:



Filter
Matches




criteria.from='sender@example.com'
All emails from sender@example.com


criteria.size=10485760criteria.sizeComparison='larger'
All emails larger than 10MB


criteria.hasAttachment=true
All emails with an attachment


criteria.subject='[People with Pets]'
All emails with the string [People with Pets] in the subject


criteria.query='"my important project"'
All emails containing the string my important project


criteria.negatedQuery='"secret knock"'
All emails that do not contain the string secret knock



If multiple criteria are present in a filter, a message must satisfy all
criteria for the filter to apply.
Actions
You can apply an action
to messages matching the filter criteria. Messages may be forwarded to a
verified email address, or have labels added or removed.
You can add or remove labels to change the disposition of the email. For example,
some common actions include:



Action
Effect




action.removeLabelIds=['INBOX']
Archive the email (skip the inbox)


action.removeLabelIds=['UNREAD']
Mark as read


action.removeLabelIds=['SPAM']
Never mark as spam


action.removeLabelIds=['IMPORTANT']
Never mark as important


action.addLabelIds=['IMPORTANT']
Mark as important


action.addLabelIds=['TRASH']
Delete the email


action.addLabelIds=['STARRED']
Mark as starred


action.addLabelIds=['<user label id>']
Tag the mail with a user-defined label. Only one user-defined label is allowed per filter.



Examples
The following is a more complete example showing how to label and archive
messages from a mailing list.

Java


gmail/snippets/src/main/java/CreateFilter.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Filter;
import com.google.api.services.gmail.model.FilterAction;
import com.google.api.services.gmail.model.FilterCriteria;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;
import java.util.Arrays;

/* Class to demonstrate the use of Gmail Create Filter API */
public class CreateFilter {
  /**
   * Create a new filter.
   *
   * @param labelId - ID of the user label to add
   * @return the created filter id, {@code null} otherwise.
   * @throws IOException - if service account credentials file not found.
   */
  public static String createNewFilter(String labelId) throws IOException {
        /* Load pre-authorized user credentials from the environment.
           TODO(developer) - See https://developers.google.com/identity for
            guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SETTINGS_BASIC,
            GmailScopes.GMAIL_LABELS);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    try {
      // Filter the mail from sender and archive them(skip the inbox)
      Filter filter = new Filter()
          .setCriteria(new FilterCriteria()
              .setFrom("gduser2@workspacesamples.dev"))
          .setAction(new FilterAction()
              .setAddLabelIds(Arrays.asList(labelId))
              .setRemoveLabelIds(Arrays.asList("INBOX")));

      Filter result = service.users().settings().filters().create("me", filter).execute();
      // Prints the new created filter ID
      System.out.println("Created filter " + result.getId());
      return result.getId();
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to create filter: " + e.getDetails());
      } else {
        throw e;
      }
    }
    return null;
  }
}


Python


gmail/snippet/settings snippets/create_filter.py

View on GitHub



import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def create_filter():
  """Create a filter.
  Returns: Draft object, including filter id.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    label_name = "IMPORTANT"
    filter_content = {
        "criteria": {"from": "gsuder1@workspacesamples.dev"},
        "action": {
            "addLabelIds": [label_name],
            "removeLabelIds": ["INBOX"],
        },
    }

    # pylint: disable=E1101
    result = (
        service.users()
        .settings()
        .filters()
        .create(userId="me", body=filter_content)
        .execute()
    )
    print(f'Created filter with id: {result.get("id")}')

  except HttpError as error:
    print(f"An error occurred: {error}")
    result = None

  return result.get("id")


if __name__ == "__main__":
  create_filter()





You can use Settings to
configure scheduled auto-reply for an account.
For information on how to
get or
update,
see the Settings reference.
Configuring auto-reply
Auto-reply requires a response subject and body, either HTML or plain text. It
can be enabled indefinitely, or limited to a defined period of time. You can
also restrict auto-reply to known contacts or domain members.
Example of setting an auto-reply for a fixed period of time, restricting replies
to users in the same domain:

Java


gmail/snippets/src/main/java/EnableAutoReply.java

View on GitHub




import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.VacationSettings;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;

/* Class to demonstrate the use of Gmail Enable Auto Reply API*/
public class EnableAutoReply {
  /**
   * Enables the auto reply
   *
   * @return the reply message and response metadata.
   * @throws IOException - if service account credentials file not found.
   */
  public static VacationSettings autoReply() throws IOException {
        /* Load pre-authorized user credentials from the environment.
          TODO(developer) - See https://developers.google.com/identity for
           guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SETTINGS_BASIC);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    try {
      // Enable auto reply by restricting domain with start time and end time
      VacationSettings vacationSettings = new VacationSettings()
          .setEnableAutoReply(true)
          .setResponseBodyHtml(
              "I am on vacation and will reply when I am back in the office. Thanks!")
          .setRestrictToDomain(true)
          .setStartTime(LocalDateTime.now()
              .toEpochSecond(ZoneOffset.from(ZonedDateTime.now())) * 1000)
          .setEndTime(LocalDateTime.now().plusDays(7)
              .toEpochSecond(ZoneOffset.from(ZonedDateTime.now())) * 1000);

      VacationSettings response = service.users().settings()
          .updateVacation("me", vacationSettings).execute();
      // Prints the auto-reply response body
      System.out.println("Enabled auto reply with message : " + response.getResponseBodyHtml());
      return response;
    } catch (GoogleJsonResponseException e) {
      // TODO(developer) - handle error appropriately
      GoogleJsonError error = e.getDetails();
      if (error.getCode() == 403) {
        System.err.println("Unable to enable auto reply: " + e.getDetails());
      } else {
        throw e;
      }
    }
    return null;
  }
}


Python


gmail/snippet/settings snippets/enable_auto_reply.py

View on GitHub



from datetime import datetime, timedelta

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from numpy import long


def enable_auto_reply():
  """Enable auto reply.
  Returns:Draft object, including reply message and response meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    epoch = datetime.utcfromtimestamp(0)
    now = datetime.now()
    start_time = (now - epoch).total_seconds() * 1000
    end_time = (now + timedelta(days=7) - epoch).total_seconds() * 1000
    vacation_settings = {
        "enableAutoReply": True,
        "responseBodyHtml": (
            "I am on vacation and will reply when I am "
            "back in the office. Thanks!"
        ),
        "restrictToDomain": True,
        "startTime": long(start_time),
        "endTime": long(end_time),
    }

    # pylint: disable=E1101
    response = (
        service.users()
        .settings()
        .updateVacation(userId="me", body=vacation_settings)
        .execute()
    )
    print(f"Enabled AutoReply with message: {response.get('responseBodyHtml')}")

  except HttpError as error:
    print(f"An error occurred: {error}")
    response = None

  return response


if __name__ == "__main__":
  enable_auto_reply()



To disable auto-reply, update the resource and set enableAutoReply to
false. If an endTime is configured, auto-reply will automatically disable
once the specified time has passed.


The Gmail S/MIME API provides programmatic access to manage S/MIME email
certificates for users in a Google Workspace domain.
An administrator must enable S/MIME for the
domain in order for
the certificates to work.
The S/MIME standard provides a
specification for public key encryption and signing of MIME data. Configuring
S/MIME certificates in a user's account causes Gmail to use that certificate in
the following ways:

Gmail uses the user's certificate and private key to sign outgoing mail.
Gmail uses the user's private key to decrypt incoming mail.
Gmail uses the recipient's certificate and public key to encrypt outgoing mail.
Gmail uses the sender's certificate and public key to verify incoming mail.

You generate individual S/MIME certificates and upload them using the API. Each
S/MIME certificate is for a specific alias for a user email account.
Aliases include the primary email address as well as custom "Send As" addresses.
A single S/MIME cert is marked as the default for each alias.
Authorizing API access
There are two forms of authorizing access to the API:

You can use a service account with domain-wide delegation of authority.
For an explanation of these terms, refer to
Authentication and authorization overview terms.
For information on enabling this option, refer to
Create a service account with domain-wide delegation of authority 
You can use a standard OAuth2 flow requiring end-user
consent to obtain an Oauth2 access token. For further information, refer to
the Authentication and authorization overview 
To use this option, the domain admin must enable the
"S/MIME API end user access enabled" checkbox in the Domain control panel.

ACL scopes
This API relies on the same ACL
scopes as the
Gmail sendAs methods:

gmail.settings.basic
This scope is required for updating the primary SendAs S/MIME.
gmail.settings.sharing
This scope is required for updating custom from S/MIME.

Using the API
The users.settings.sendAs.smimeInfo
resource provides the methods that you use to manage S/MIME certificates. Each
certificate is associated with one send-as alias for a user.
Note: To determine the send-as aliases that exist for a user,  use the sendAs.list() method.
Upload an S/MIME key
Use the smimeInfo.insert() method to
upload a new S/MIME key for an alias belonging to a user.
You identify the target alias using the following parameters:

userId
The user's email address. You can use the special value me to indicate the currently authenticated user.
sendAsEmail
The alias for which you're uploading the key. This is the email address that appears in the "From:" header for mail sent using this alias.

The S/MIME certificate and private key should
be present in the pkcs12 field in that format; no other fields should be set
in the request. The PKCS12 field is expected to contain both the user S/MIME key
and the signing certificate chain. The API performs standard validations on this
field before accepting it, verifying the following:

The subject matches the specified email address.
Expirations are valid.
The issuing certificate authority (CA) is in our trusted list.
The certificates match Gmail's technical constraints.

If the key is encrypted then the password should be in encryptedKeyPassword
field. Successful insert() calls will return the smimeInfo's ID that can be
used to refer to the key in the future.
List a user's S/MIME keys
Use the smimeInfo.list() method to
return the list of S/MIME keys for the given user for the given alias.
You identify the target alias using the following parameters:

userId
The user's email address. You can use the special value me to indicate the currently authenticated user.
sendAsEmail
The alias for which to list keys. This is the email address that appears in the "From:" header for mail sent using this alias.

Keys are only returned in pem format and only contain the S/MIME
certificate, not the private key.
Retrieve the S/MIME keys for an alias
Use the smimeInfo.get() method to
return the specific S/MIME keys for a specific send-as alias for a user.
You identify the target alias using the following parameters:

userId
The user's email address. You can use the special value me to indicate the currently authenticated user.
sendAsEmail
The alias for which you're retrieving the keys. This is the email address that appears in the "From:" header for mail sent using this alias.

Keys are only returned in pem format and only contain the S/MIME
certificate, not the private key.
Delete an S/MIME key
Use the smimeInfo.delete() method to
delete the specified S/MIME key from an alias.
You identify the target alias using the following parameters:

userId
The user's email address. You can use the special value me to indicate the currently authenticated user.
sendAsEmail
The alias for which you're retrieving the keys. This is the email address that appears in the "From:" header for mail sent using this alias.
id
The immutable ID for the SmimeInfo.

A deleted key is no longer visible or usable and S/MIME emails received that are encrypted using the corresponding public key aren't decryptable. It is therefore recommended that the key be revoked with its issuing authority (CA) before it is deleted.

Set the default S/MIME key for an alias
Use the smimeInfo.setDefault() method to
mark the specified S/MIME key as the default for the specified alias.
You identify the target alias using the following parameters:

userId
The user's email address. You can use the special value me to indicate the currently authenticated user.
sendAsEmail
The alias for which you're retrieving the keys. This is the email address that appears in the "From:" header for mail sent using this alias.
id
The immutable ID for the SmimeInfo.

One and only one S/MIME key is default for a user's
SendAs: calling setDefault() will unset the previous default.
When receiving S/MIME messages signed with a given key,
Gmail associates the key with the not_before validity date
farthest in the future as the default when encrypting mail sent to the
associated user. To ensure that the new default key is used by Gmail users with
whom the user has already communicated, ensure that the new default key has a
not_before date later than the previous default key or revoke the
previous default key.

Sample code
The following code samples demonstrate using the API to manage S/MIME
certificates for an organization with multiple users.
Creating an SmimeInfo resource for an S/MIME certificate
The following code sample demonstrates reading a certificate from file, encoding
to a base64url string, and assigning it to the pkcs12 field of the smimeInfo
resource:

Java


gmail/snippets/src/main/java/CreateSmimeInfo.java

View on GitHub




import com.google.api.services.gmail.model.SmimeInfo;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Base64;

/* Class to demonstrate the use of Gmail Create SmimeInfo API */
public class CreateSmimeInfo {
  /**
   * Create an SmimeInfo resource for a certificate from file.
   *
   * @param filename Name of the file containing the S/MIME certificate.
   * @param password Password for the certificate file, or null if the file is not
   *                 password-protected.
   * @return An SmimeInfo object with the specified certificate.
   */
  public static SmimeInfo createSmimeInfo(String filename, String password) {
    SmimeInfo smimeInfo = null;
    InputStream in = null;

    try {
      File file = new File(filename);
      in = new FileInputStream(file);
      byte[] fileContent = new byte[(int) file.length()];
      in.read(fileContent);

      smimeInfo = new SmimeInfo();
      smimeInfo.setPkcs12(Base64.getUrlEncoder().encodeToString(fileContent));
      if (password != null && password.length() > 0) {
        smimeInfo.setEncryptedKeyPassword(password);
      }
    } catch (Exception e) {
      System.out.printf("An error occured while reading the certificate file: %s\n", e);
    } finally {
      try {
        if (in != null) {
          in.close();
        }
      } catch (IOException ioe) {
        System.out.printf("An error occured while closing the input stream: %s\n", ioe);
      }
    }
    return smimeInfo;
  }
}


Python


gmail/snippet/smime snippets/create_smime_info.py

View on GitHub



import base64


def create_smime_info(cert_filename, cert_password):
  """Create an smimeInfo resource for a certificate from file.
  Args:
    cert_filename: Name of the file containing the S/MIME certificate.
    cert_password: Password for the certificate file, or None if the file is not
        password-protected.
  Returns : Smime object, including smime information
  """

  smime_info = None
  try:
    with open(cert_filename, "rb") as cert:
      smime_info = {}
      data = cert.read().encode("UTF-8")
      smime_info["pkcs12"] = base64.urlsafe_b64encode(data).decode()
      if cert_password and len(cert_password) > 0:
        smime_info["encryptedKeyPassword"] = cert_password

  except (OSError, IOError) as error:
    print(f"An error occurred while reading the certificate file: {error}")
    smime_info = None

  return smime_info


if __name__ == "__main__":
  print(create_smime_info(cert_filename="xyz", cert_password="xyz"))



Uploading an S/MIME certificate
To upload a certificate, call
smimeInfo.insert,
and supply the smimeInfo resource in the body of the request:

Java


gmail/snippets/src/main/java/InsertSmimeInfo.java

View on GitHub




import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.SmimeInfo;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;

/* Class to demonstrate the use of Gmail Insert Smime Certificate API*/
public class InsertSmimeInfo {
  /**
   * Upload an S/MIME certificate for the user.
   *
   * @param userId      User's email address.
   * @param sendAsEmail The "send as" email address, or null if it should be the same as userId.
   * @param smimeInfo   The SmimeInfo object containing the user's S/MIME certificate.
   * @return An SmimeInfo object with details about the uploaded certificate, {@code null} otherwise.
   * @throws IOException - if service account credentials file not found.
   */
  public static SmimeInfo insertSmimeInfo(String userId,
                                          String sendAsEmail,
                                          SmimeInfo smimeInfo)
      throws IOException {
        /* Load pre-authorized user credentials from the environment.
           TODO(developer) - See https://developers.google.com/identity for
            guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SETTINGS_SHARING);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(
        credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    if (sendAsEmail == null) {
      sendAsEmail = userId;
    }

    try {
      SmimeInfo results = service.users().settings().sendAs().smimeInfo()
          .insert(userId, sendAsEmail, smimeInfo)
          .execute();
      System.out.printf("Inserted certificate, id: %s\n", results.getId());
      return results;
    } catch (IOException e) {
      System.err.printf("An error occured: %s", e);
    }
    return null;
  }
}


Python


gmail/snippet/smime snippets/insert_smime_info.py

View on GitHub



import create_smime_info
import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def insert_smime_info():
  """Upload an S/MIME certificate for the user.
  Print the inserted certificate's id
  Returns : Result object with inserted certificate id and other meta-data

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    user_id = "gduser1@workspacesamples.dev"
    smime_info = create_smime_info.create_smime_info(
        cert_filename="xyz", cert_password="xyz"
    )
    send_as_email = None

    if not send_as_email:
      send_as_email = user_id

    # pylint: disable=maybe-no-member
    results = (
        service.users()
        .settings()
        .sendAs()
        .smimeInfo()
        .insert(userId=user_id, sendAsEmail=send_as_email, body=smime_info)
        .execute()
    )
    print(f'Inserted certificate; id: {results["id"]}')

  except HttpError as error:
    print(f"An error occurred: {error}")
    results = None

  return results


if __name__ == "__main__":
  insert_smime_info()



Examples for managing many users' certificates
You may want to manage certificates for many users in the organization at once.
The following examples show how to manage certificates for multiple users in one
batch call.
Inserting certificates from a CSV file
Suppose you have a CSV file that lists user IDs and the path to each user's
certificate:
$ cat certificates.csv
user1@example.com,/path/to/user1_cert.p12,cert_password_1
user2@example.com,/path/to/user2_cert.p12,cert_password_2
user3@example.com,/path/to/user3_cert.p12,cert_password_3

JavaYou can make use of the createSmimeInfo and insertSmimeInfo calls
from earlier to upload the certs as specified in the CSV file:


gmail/snippets/src/main/java/InsertCertFromCsv.java

View on GitHub




import com.google.api.services.gmail.model.SmimeInfo;
import java.io.File;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;

/* Class to demonstrate the use of Gmail Insert Certificate from CSV File */
public class InsertCertFromCsv {
  /**
   * Upload S/MIME certificates based on the contents of a CSV file.
   *
   * <p>Each row of the CSV file should contain a user ID, path to the certificate, and the
   * certificate password.
   *
   * @param csvFilename Name of the CSV file.
   */
  public static void insertCertFromCsv(String csvFilename) {
    try {
      File csvFile = new File(csvFilename);
      CSVParser parser =
          CSVParser.parse(csvFile, java.nio.charset.StandardCharsets.UTF_8, CSVFormat.DEFAULT);
      for (CSVRecord record : parser) {
        String userId = record.get(0);
        String certFilename = record.get(1);
        String certPassword = record.get(2);
        SmimeInfo smimeInfo = CreateSmimeInfo.createSmimeInfo(certFilename,
            certPassword);
        if (smimeInfo != null) {
          InsertSmimeInfo.insertSmimeInfo(userId,
              userId,
              smimeInfo);
        } else {
          System.err.printf("Unable to read certificate file for userId: %s\n", userId);
        }
      }
    } catch (Exception e) {
      System.err.printf("An error occured while reading the CSV file: %s", e);
    }
  }
}


PythonYou can make use of the create_smime_info and insert_smime_info calls
from earlier to upload the certs as specified in the CSV file:


gmail/snippet/smime snippets/insert_cert_from_csv.py

View on GitHub



import csv

import create_smime_info
import insert_smime_info


def insert_cert_from_csv(csv_filename):
  """Upload S/MIME certificates based on the contents of a CSV file.
  Each row of the CSV file should contain a user ID, path to the certificate,
  and the certificate password.

  Args:
    csv_filename: Name of the CSV file.
  """

  try:
    with open(csv_filename, "rb") as cert:
      csv_reader = csv.reader(cert, delimiter=",")
      next(csv_reader, None)  # skip CSV file header
      for row in csv_reader:
        user_id = row[0]
        cert_filename = row[1]
        cert_password = row[2]
        smime_info = create_smime_info.create_smime_info(
            cert_filename=cert_filename, cert_password=cert_password
        )
        if smime_info:
          insert_smime_info.insert_smime_info()
        else:
          print(f"Unable to read certificate file for user_id: {user_id}")
        return smime_info

  except (OSError, IOError) as error:
    print(f"An error occured while reading the CSV file: {error}")


if __name__ == "__main__":
  insert_cert_from_csv(csv_filename="xyz")



Certificate management
This example combines several calls from the smimeInfo API to show how you
might manage certificates for your organization.  It lists the certs for the
user and if the default cert is expired or not set, it uploads the cert found in
the specified file.  Then it sets the cert whose expiration is furthest into the
future as the default.
This is then called from a function that processes a CSV file as in the previous
example.

Java


gmail/snippets/src/main/java/UpdateSmimeCerts.java

View on GitHub




import com.google.api.client.http.HttpRequestInitializer;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.ListSmimeInfoResponse;
import com.google.api.services.gmail.model.SmimeInfo;
import com.google.auth.http.HttpCredentialsAdapter;
import com.google.auth.oauth2.GoogleCredentials;
import java.io.IOException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;

/* Class to demonstrate the use of Gmail Update Smime Certificate API*/
public class UpdateSmimeCerts {
  /**
   * Update S/MIME certificates for the user.
   *
   * <p>First performs a lookup of all certificates for a user. If there are no certificates, or
   * they all expire before the specified date/time, uploads the certificate in the specified file.
   * If the default certificate is expired or there was no default set, chooses the certificate with
   * the expiration furthest into the future and sets it as default.
   *
   * @param userId       User's email address.
   * @param sendAsEmail  The "send as" email address, or None if it should be the same as user_id.
   * @param certFilename Name of the file containing the S/MIME certificate.
   * @param certPassword Password for the certificate file, or None if the file is not
   *                     password-protected.
   * @param expireTime   DateTime object against which the certificate expiration is compared. If
   *                     None, uses the current time. @ returns: The ID of the default certificate.
   * @return The ID of the default certificate, {@code null} otherwise.
   * @throws IOException - if service account credentials file not found.
   */
  public static String updateSmimeCerts(String userId,
                                        String sendAsEmail,
                                        String certFilename,
                                        String certPassword,
                                        LocalDateTime expireTime)
      throws IOException {
        /* Load pre-authorized user credentials from the environment.
           TODO(developer) - See https://developers.google.com/identity for
            guides on implementing OAuth2 for your application. */
    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()
        .createScoped(GmailScopes.GMAIL_SETTINGS_SHARING);
    HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(
        credentials);

    // Create the gmail API client
    Gmail service = new Gmail.Builder(new NetHttpTransport(),
        GsonFactory.getDefaultInstance(),
        requestInitializer)
        .setApplicationName("Gmail samples")
        .build();

    if (sendAsEmail == null) {
      sendAsEmail = userId;
    }

    ListSmimeInfoResponse listResults;
    try {
      listResults =
          service.users().settings().sendAs().smimeInfo().list(userId, sendAsEmail).execute();
    } catch (IOException e) {
      System.err.printf("An error occurred during list: %s\n", e);
      return null;
    }

    String defaultCertId = null;
    String bestCertId = null;
    LocalDateTime bestCertExpire = LocalDateTime.MIN;

    if (expireTime == null) {
      expireTime = LocalDateTime.now();
    }
    if (listResults != null && listResults.getSmimeInfo() != null) {
      for (SmimeInfo smimeInfo : listResults.getSmimeInfo()) {
        String certId = smimeInfo.getId();
        boolean isDefaultCert = smimeInfo.getIsDefault();
        if (isDefaultCert) {
          defaultCertId = certId;
        }
        LocalDateTime exp =
            LocalDateTime.ofInstant(
                Instant.ofEpochMilli(smimeInfo.getExpiration()), ZoneId.systemDefault());
        if (exp.isAfter(expireTime)) {
          if (exp.isAfter(bestCertExpire)) {
            bestCertId = certId;
            bestCertExpire = exp;
          }
        } else {
          if (isDefaultCert) {
            defaultCertId = null;
          }
        }
      }
    }
    if (defaultCertId == null) {
      String defaultId = bestCertId;
      if (defaultId == null && certFilename != null) {
        SmimeInfo smimeInfo = CreateSmimeInfo.createSmimeInfo(certFilename,
            certPassword);
        SmimeInfo insertResults = InsertSmimeInfo.insertSmimeInfo(userId,
            sendAsEmail,
            smimeInfo);
        if (insertResults != null) {
          defaultId = insertResults.getId();
        }
      }

      if (defaultId != null) {
        try {
          service.users().settings().sendAs().smimeInfo().setDefault(userId, sendAsEmail, defaultId)
              .execute();
          return defaultId;
        } catch (IOException e) {
          System.err.printf("An error occured during setDefault: %s", e);
        }
      }
    } else {
      return defaultCertId;
    }

    return null;
  }
}


Python


gmail/snippet/smime snippets/update_smime_cert.py

View on GitHub



from datetime import datetime

import create_smime_info
import google.auth
import insert_smime_info
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def update_smime_cert(
    user_id, send_as_email, cert_filename, cert_password, expire_dt
):
  """Update S/MIME certificates for the user.

  First performs a lookup of all certificates for a user.  If there are no
  certificates, or they all expire before the specified date/time, uploads the
  certificate in the specified file.  If the default certificate is expired or
  there was no default set, chooses the certificate with the expiration furthest
  into the future and sets it as default.

  Args:
    user_id: User's email address.
    send_as_email: The "send as" email address, or None if it should be the same
        as user_id.
    cert_filename: Name of the file containing the S/MIME certificate.
    cert_password: Password for the certificate file, or None if the file is not
        password-protected.
    expire_dt: DateTime object against which the certificate expiration is
      compared.  If None, uses the current time.

  Returns:
    The ID of the default certificate.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  if not send_as_email:
    send_as_email = user_id

  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    # pylint: disable=maybe-no-member
    results = (
        service.users()
        .settings()
        .sendAs()
        .smimeInfo()
        .list(userId=user_id, sendAsEmail=send_as_email)
        .execute()
    )

  except HttpError as error:
    print(f"An error occurred during list: {error}")
    return None

  default_cert_id = None
  best_cert_id = (None, datetime.datetime.fromtimestamp(0))

  if not expire_dt:
    expire_dt = datetime.datetime.now()
  if results and "smimeInfo" in results:
    for smime_info in results["smimeInfo"]:
      cert_id = smime_info["id"]
      is_default_cert = smime_info["isDefault"]
      if is_default_cert:
        default_cert_id = cert_id
      exp = datetime.datetime.fromtimestamp(smime_info["expiration"] / 1000)
      if exp > expire_dt:
        if exp > best_cert_id[1]:
          best_cert_id = (cert_id, exp)
      else:
        if is_default_cert:
          default_cert_id = None

  if not default_cert_id:
    default_id = best_cert_id[0]
    if not default_id and cert_filename:
      create_smime_info.create_smime_info(
          cert_filename=cert_filename, cert_password=cert_password
      )
      results = insert_smime_info.insert_smime_info()
      if results:
        default_id = results["id"]

    if default_id:
      try:
        # pylint: disable=maybe-no-member
        service.users().settings().sendAs().smimeInfo().setDefault(
            userId=user_id, sendAsEmail=send_as_email, id=default_id
        ).execute()
        return default_id
      except HttpError as error:
        print(f"An error occurred during setDefault: {error}")
  else:
    return default_cert_id

  return None


if __name__ == "__main__":
  update_smime_cert(
      user_id="xyz",
      send_as_email=None,
      cert_filename="xyz",
      cert_password="xyz",
      expire_dt=None,
  )





You can use Settings to configure
the behavior of Gmail when accessed via the POP and IMAP protocols.
For information on how to
getPop,
updatePop,
getImap,
or updateImap, see
the Settings reference.
POP
Enabling and disabling access
You can control POP access with the accessWindow property. The property not
only determines whether or not POP is enabled, but also which messages may be
retrieved.



Value
Effect




disabled
No POP access


allMail
All messages are available


fromNowOn
Only new messages are available



Message disposition
You can configure the disposition of messages retrieved via POP with
the disposition property.



Value
Effect




archive
Move messages out of the inbox


leaveInInbox
Do nothing, leave messages unread in the inbox


markRead
Mark the messages as read


trash
Moves the message to the trash



IMAP
Enabling and disabling access
You can control IMAP access by setting the enabled property to true
or false, to enable or disable access respectively.
Message Disposition
To set the disposition for deleted messages, use the expungeBehavior property.



Value
Effect




archive
Move messages out of the inbox


deleteForever
Permanently delete the message


trash
Moves the message to the trash



Additionally, if the autoExpunge property is set to true these actions
are performed immediately when the message is deleted via IMAP. Otherwise
messages are left until explicitly requested from the IMAP client.


A Gmail user can grant mailbox access to another user in the same
Google Workspace organization. The user granting
access is referred to as the delegator
and the user receiving the access is the delegate.
Delegates can read, send, and delete messages, as well as view and add contacts,
for the delegator's account. See
Set up mail delegation
for more information about delegates.
Google Workspace organizations can use the
Delegates resource to
manage the delegates of accounts in their organization. This requires use of a
service account that has been
delegated domain-wide authority.
The Delegates reference
contains more information on how to
create,
list,
get,
or delete delegates.


The following document will help you access the read-only Gmail inbox feed.
About Atom
Atom is a system which makes it easy for you to receive, in one place, regular
updates from news websites, blogs, and/or Gmail. You can use Atom with an
aggregator (also known as a newsreader, feed reader, or RSS/Atom reader) to
receive new message alerts.
Note: This feed is only available for Gmail accounts on
Google Workspace domains.
Using the Inbox Feed
The Gmail Inbox Feed will output your Inbox as an XML document. You can use
an RSS aggregator to view this, or you can consume the feed with your own app.
OAuth 2.0 is the preferred authentication method,
using the scope https://mail.google.com/mail/feed/atom and fetching the feed
with the request GET https://mail.google.com/mail/feed/atom.


This document shows how to batch API calls together to reduce the number of HTTP connections
your client has to make.
This document is specifically about making a batch request by sending an
HTTP request. If, instead, you're using a Google client library to make a batch request, see the client library's documentation.

Overview
Each HTTP connection your client makes results in a certain amount of overhead. The Gmail API supports batching, to allow your client to put several API calls into a single HTTP request.
Examples of situations when you might want to use batching:

You've just started using the API and you have a lot of data to upload.
A user made changes to data while your application was offline (disconnected from the Internet), so your application needs to synchronize its local data with the server by sending a lot of updates and deletes.

In each case, instead of sending each call separately, you can group them together into a single HTTP request. All the inner requests must go to the same Google API.
You're limited to 100 calls in a single batch request. If you must make more calls than that, use multiple batch requests.
Note: The batch system for the Gmail API uses the same syntax as the OData batch processing system, but the semantics differ.
Note: Larger batch sizes are likely to trigger rate
limiting. Sending batches larger than 50 requests is not recommended.



Batch details
A batch request consists of multiple API calls combined into one HTTP request, which can be sent to the batchPath specified in the API discovery document. The default path is /batch/api_name/api_version. This section describes the batch syntax in detail; later, there's an example.
Note: A set of n requests batched together counts toward your usage limit as n requests, not as one request. The batch request is separated into a set of requests before processing.
Format of a batch request
A batch request is a single standard HTTP request containing multiple Gmail API calls, using the multipart/mixed content type. Within that main HTTP request, each of the parts contains a nested HTTP request.
Each part begins with its own Content-Type: application/http HTTP header. It can also have an optional Content-ID header. However, the part headers are just there to mark the beginning of the part; they're separate from the nested request. After the server unwraps the batch request into separate requests, the part headers are ignored.
The body of each part is a complete HTTP request, with its own verb, URL, headers, and body. The HTTP request must only contain the path portion of the URL; full URLs are not allowed in batch requests.
The HTTP headers for the outer batch request, except for the Content- headers such as Content-Type, apply to every request in the batch. If you specify a given HTTP header in both the outer request and an individual call, then the individual call header's value overrides the outer batch request header's value. The headers for an individual call apply only to that call.
For example, if you provide an Authorization header for a specific call, then that header applies only to that call. If you provide an Authorization header for the outer request, then that header applies to all of the individual calls unless they override it with Authorization headers of their own.
When the server receives the batched request, it applies the outer request's query parameters and headers (as appropriate) to each part, and then treats each part as if it were a separate HTTP request.
Response to a batch request
The server's response is a single standard HTTP response with a multipart/mixed content type; each part is the response to one of the requests in the batched request, in the same order as the requests.
Like the parts in the request, each response part contains a complete HTTP response, including a status code, headers, and body. And like the parts in the request, each response part is preceded by a Content-Type header that marks the beginning of the part.
If a given part of the request had a Content-ID header, then the corresponding part of the response has a matching Content-ID header, with the original value preceded by the string response-, as shown in the following example.
Note: The server might perform your calls in any order. Don't count on their being executed in the order in which you specified them. If you want to ensure that two calls occur in a given order, you can't send them in a single request; instead, send the first one by itself, then wait for the response to the first one before sending the second one.


Example
The following example shows the use of batching with a generic (fictional) demo API called the Farm API. However, the same concepts apply to the Gmail API.
Example batch request

POST /batch/farm/v1 HTTP/1.1
Authorization: Bearer your_auth_token
Host: www.googleapis.com
Content-Type: multipart/mixed; boundary=batch_foobarbaz
Content-Length: total_content_length

--batch_foobarbaz
Content-Type: application/http
Content-ID: <item1:12930812@barnyard.example.com>

GET /farm/v1/animals/pony

--batch_foobarbaz
Content-Type: application/http
Content-ID: <item2:12930812@barnyard.example.com>

PUT /farm/v1/animals/sheep
Content-Type: application/json
Content-Length: part_content_length
If-Match: "etag/sheep"

{
  "animalName": "sheep",
  "animalAge": "5"
  "peltColor": "green",
}

--batch_foobarbaz
Content-Type: application/http
Content-ID: <item3:12930812@barnyard.example.com>

GET /farm/v1/animals
If-None-Match: "etag/animals"

--batch_foobarbaz--

Example batch response
This is the response to the example request in the previous section.

HTTP/1.1 200
Content-Length: response_total_content_length
Content-Type: multipart/mixed; boundary=batch_foobarbaz

--batch_foobarbaz
Content-Type: application/http
Content-ID: <response-item1:12930812@barnyard.example.com>

HTTP/1.1 200 OK
Content-Type application/json
Content-Length: response_part_1_content_length
ETag: "etag/pony"

{
  "kind": "farm#animal",
  "etag": "etag/pony",
  "selfLink": "/farm/v1/animals/pony",
  "animalName": "pony",
  "animalAge": 34,
  "peltColor": "white"
}

--batch_foobarbaz
Content-Type: application/http
Content-ID: <response-item2:12930812@barnyard.example.com>

HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: response_part_2_content_length
ETag: "etag/sheep"

{
  "kind": "farm#animal",
  "etag": "etag/sheep",
  "selfLink": "/farm/v1/animals/sheep",
  "animalName": "sheep",
  "animalAge": 5,
  "peltColor": "green"
}

--batch_foobarbaz
Content-Type: application/http
Content-ID: <response-item3:12930812@barnyard.example.com>

HTTP/1.1 304 Not Modified
ETag: "etag/animals"

--batch_foobarbaz--




This document covers some techniques you can use to improve the performance of your application. In some cases, examples from other APIs or generic APIs are used to illustrate the ideas presented. However, the same concepts are applicable to the Gmail API.

Compression using gzip
An easy and convenient way to reduce the bandwidth needed for each request is to enable gzip compression. Although this requires additional CPU time to uncompress the results, the trade-off with network costs usually makes it very worthwhile.
In order to receive a gzip-encoded response you must do two things: Set an Accept-Encoding header, and modify your user agent to contain the string gzip. Here is an example of properly formed HTTP headers for enabling gzip compression:
Accept-Encoding: gzip
User-Agent: my program (gzip)



Working with partial resources
Another way to improve the performance of your API calls is by sending and receiving only the portion of the  data that you're interested in. This lets your application avoid transferring, parsing, and storing unneeded fields, so it can use resources including network, CPU, and memory more efficiently.
There are two types of partial requests:

Partial response: A request where you specify which fields to include in the response (use the fields request parameter).
Patch: An update request where you send only the fields you want to change (use the PATCH HTTP verb).

More details on making partial requests are provided in the following sections.
Partial response
By default, the server sends back the full representation of a resource after processing requests. For better performance, you can ask the server to send only the fields you really need and get a partial response instead.
To request a partial response, use the fields request parameter to specify the fields you want returned. You can use this parameter with any request that returns response data.
Note that the fields parameter only affects the response data; it does not affect the data that you need to send, if any. To reduce the amount of data you send when modifying resources, use a patch request.
Example
The following example shows the use of the fields parameter with a generic (fictional) "Demo" API.
Simple request: This HTTP GET request omits the fields parameter and returns the full resource.

https://www.googleapis.com/demo/v1

Full resource response: The full resource data includes the following fields, along with many others that have been omitted for brevity.

{
  "kind": "demo",
  ...
  "items": [
  {
    "title": "First title",
    "comment": "First comment.",
    "characteristics": {
      "length": "short",
      "accuracy": "high",
      "followers": ["Jo", "Will"],
    },
    "status": "active",
    ...
  },
  {
    "title": "Second title",
    "comment": "Second comment.",
    "characteristics": {
      "length": "long",
      "accuracy": "medium"
      "followers": [ ],
    },
    "status": "pending",
    ...
  },
  ...
  ]
}

Request for a partial response: The following request for this same resource uses the fields parameter to significantly reduce the amount of data returned.

https://www.googleapis.com/demo/v1?fields=kind,items(title,characteristics/length)

Partial response: In response to the request above, the server sends back a response that contains only the kind information along with a pared-down items array that includes only HTML title and length characteristic information in each item.
200 OK
{
  "kind": "demo",
  "items": [{
    "title": "First title",
    "characteristics": {
      "length": "short"
    }
  }, {
    "title": "Second title",
    "characteristics": {
      "length": "long"
    }
  },
  ...
  ]
}
Note that the response is a JSON object that includes only the selected fields and their enclosing parent objects.
Details on how to format the fields parameter is covered next, followed by more details about what exactly gets returned in the response.
Fields parameter syntax summary
The format of the fields request parameter value is loosely based on XPath syntax. The supported syntax is summarized below, and additional examples are provided in the following section.

Use a comma-separated list to select multiple fields.
Use a/b to select a field b that is nested within field a; use a/b/c to select a field c nested within b. 
Exception: For API responses that use "data" wrappers, where the response is nested within a data object that looks like data: { ... }, do not include "data" in the fields specification.  Including the data object with a fields specification like data/a/b causes an error. Instead, just use a fields specification like a/b.
Use a sub-selector to request a set of specific sub-fields of arrays or objects by placing expressions in parentheses "( )".
      For example: fields=items(id,author/email) returns only the item ID and author's email for each element in the items array. You can also specify a single sub-field, where fields=items(id) is equivalent to fields=items/id.

Use wildcards in field selections, if needed.
      For example: fields=items/pagemap/* selects all objects in a pagemap.


More examples of using the fields parameter
The examples below include descriptions of how the fields parameter value affects the response.
Note: As with all query parameter values, the fields parameter value must be URL encoded. For better readability, the examples in this document omit the encoding.

Identify the fields you want returned, or make field selections.
The fields request parameter value is a comma-separated list of fields, and each field is specified relative to the root of the response. Thus, if you are performing a list operation, the response is a collection, and it generally includes an array of resources. If you are performing an operation that returns a single resource, fields are specified relative to that resource. If the field you select is (or is part of) an array, the server returns the selected portion of all elements in the array.

      Here are some collection-level examples:


Examples
Effect


items
Returns all elements in the items array, including all fields in each element, but no other fields.


etag,items
Returns both the etag field  and all elements in the items array.


items/title
Returns only the title field for all elements in the items array.

            Whenever a nested field is returned, the response includes the enclosing parent objects. The parent fields do not include any other child fields unless they are also selected explicitly.


context/facets/label
Returns only the label field for all members of the facets array, which is itself nested under the context object.


items/pagemap/*/title
For each element in the items array, returns only the title field (if present) of all objects that are children of pagemap.



      Here are some resource-level examples:


Examples
Effect


title
Returns the title field of the requested resource.


author/uri
Returns the uri sub-field of the author object in the requested resource.


links/*/href
Returns the href field of all objects that are children of links.



Request only parts of specific fields using sub-selections.
By default, if your request specifies particular fields, the server returns the objects or array elements in their entirety. You can specify a response that includes only certain sub-fields. You do this using "( )" sub-selection syntax, as in the example below.
      

Example
Effect


items(title,author/uri)
Returns only the values of the title and author's uri for each element in the items array.




Handling partial responses
After a server processes a valid request that includes the fields query parameter, it sends back an HTTP 200 OK status code, along with the requested data. If the fields query parameter has an error or is otherwise invalid, the server returns an HTTP 400 Bad Request status code, along with an error message telling the user what was wrong with their fields selection (for example, "Invalid field selection a/b").
Here is the partial response example shown in the introductory section above. The request uses the fields parameter to specify which fields to return.

https://www.googleapis.com/demo/v1?fields=kind,items(title,characteristics/length)

The partial response looks like this:
200 OK
{
  "kind": "demo",
  "items": [{
    "title": "First title",
    "characteristics": {
      "length": "short"
    }
  }, {
    "title": "Second title",
    "characteristics": {
      "length": "long"
    }
  },
  ...
  ]
}
Note: For APIs that support query parameters for data pagination (maxResults and nextPageToken, for example), use those parameters to reduce the results of each query to a manageable size. Otherwise, the performance gains possible with partial response might not be realized.

 Patch (partial update)
You can also avoid sending unnecessary data when modifying resources. To send updated data only for the specific fields that you’re changing, use the HTTP PATCH verb. The patch semantics described in this document are different (and simpler) than they were for the older, GData implementation of partial update.
The short example below shows how using patch minimizes the data you need to send to make a small update.
Example
This example shows a simple patch request to update only the title of a generic (fictional) "Demo" API resource. The  resource also has a comment, a set of characteristics, status, and many other fields, but this request only sends the title field, since that's the only field being modified:
PATCH https://www.googleapis.com/demo/v1/324
Authorization: Bearer your_auth_token
Content-Type: application/json

{
  "title": "New title"
}
Response:
200 OK
{
  "title": "New title",
  "comment": "First comment.",
  "characteristics": {
    "length": "short",
    "accuracy": "high",
    "followers": ["Jo", "Will"],
  },
  "status": "active",
  ...
}
The server returns a 200 OK status code, along with the full representation of the updated resource.  Since only the title field was included in the patch request, that's the only value that is different from before.
Note: If you use the partial response fields parameter in combination with patch, you can increase the efficiency of your update requests even further. A patch request only reduces the size of the request. A partial response reduces the size of the response. So to reduce the amount of data sent in both directions, use a patch request with the fields parameter.
Semantics of a patch request
The body of the patch request includes only the resource fields you want to modify. When you specify a field, you must include any enclosing parent objects, just as the enclosing parents are returned with a partial response. The modified data you send is merged into the data for the parent object, if there is one.

Add: To add a field that doesn't already exist, specify the new field and its value.
Modify: To change the value of an existing field, specify the field and set it to the new value.

Delete: To delete a field, specify the field and set it to null. For example, "comment": null. You can also delete an entire object (if it is mutable) by setting it to null. If you are using the
    Java API Client Library, use Data.NULL_STRING instead; for
    details, see JSON null.
  

Note about arrays: Patch requests that contain arrays replace the existing array with the one you provide. You cannot modify, add, or delete items in an array in a piecemeal fashion.
Using patch in a read-modify-write cycle
It can be a useful practice to start by retrieving a partial response with the data you want to modify. This is especially important for resources that    use ETags, since you must provide the current ETag value in the If-Match HTTP header in order to update the resource successfully. After you get the data, you can then modify the values you want to change and send the modified partial representation back with a patch request. Here is an example that assumes the Demo resource uses ETags:
GET https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics
Authorization: Bearer your_auth_token
This is the partial response:
200 OK
{
  "etag": "ETagString"
  "title": "New title"
  "comment": "First comment.",
  "characteristics": {
    "length": "short",
    "level": "5",
    "followers": ["Jo", "Will"],
  }
}
The following patch request is based on that response. As shown below, it also uses the fields parameter to limit the data returned in the patch response:
PATCH https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics
Authorization: Bearer your_auth_token
Content-Type: application/json
If-Match: "ETagString"

{
  "etag": "ETagString"
  "title": "",                  /* Clear the value of the title by setting it to the empty string. */
  "comment": null,              /* Delete the comment by replacing its value with null. */
  "characteristics": {
    "length": "short",
    "level": "10",              /* Modify the level value. */
    "followers": ["Jo", "Liz"], /* Replace the followers array to delete Will and add Liz. */
    "accuracy": "high"          /* Add a new characteristic. */
  },
}
The server responds with a 200 OK HTTP status code, and the partial representation of the updated resource:
200 OK
{
  "etag": "newETagString"
  "title": "",                 /* Title is cleared; deleted comment field is missing. */
  "characteristics": {
    "length": "short",
    "level": "10",             /* Value is updated.*/
    "followers": ["Jo" "Liz"], /* New follower Liz is present; deleted Will is missing. */
    "accuracy": "high"         /* New characteristic is present. */
  }
}
Constructing a patch request directly
For some patch requests, you need to base them on the data you previously retrieved. For example, if you want to add an item to an array and don't want to lose any of the existing array elements, you must get the existing data first. Similarly, if an API uses ETags, you need to send the previous ETag value with your request in order to update the resource successfully.
Note: You can use an "If-Match: *" HTTP header to force a patch to go through when ETags are in use.  If you do this, you don't need to do the read before the write.
For other situations, however, you can construct the patch request directly, without first retrieving the existing data. For example, you can easily set up a patch request that updates a field to a new value or adds a new field. Here is an example:
PATCH https://www.googleapis.com/demo/v1/324?fields=comment,characteristics
Authorization: Bearer your_auth_token
Content-Type: application/json

{
  "comment": "A new comment",
  "characteristics": {
    "volume": "loud",
    "accuracy": null
  }
}
With this request, if the comment field has an existing value, the new value overwrites it; otherwise it is set to the new value. Similarly, if there was a volume characteristic, its value is overwritten; if not, it is created. The accuracy field, if set, is removed.
Handling the response to a patch
After processing a valid patch request, the API returns a 200 OK HTTP response code along with the complete representation of the modified resource. If ETags are used by the API, the server updates ETag values when it successfully processes a patch request, just as it does with PUT.
The patch request returns the entire resource representation unless you use the fields parameter to reduce the amount of data it returns.
If a patch request results in a new resource state that is syntactically or semantically invalid, the server returns a 400 Bad Request or 422 Unprocessable Entity HTTP status code, and the resource state remains unchanged. For example, if you attempt to delete the value for a required field, the server returns an error.  
Alternate notation when PATCH HTTP verb is not supported
If your firewall does not allow HTTP PATCH requests, then do an HTTP POST request and set the override header to PATCH, as shown below:
POST https://www.googleapis.com/...
X-HTTP-Method-Override: PATCH
...

Difference between patch and update
In practice, when you send data for an update request that uses the HTTP PUT verb, you only need to send those fields which are either required or optional; if you send values for fields that are set by the server, they are ignored. Although this might seem like another way to do a partial update, this approach has some limitations. With updates that use the HTTP PUT verb, the request fails if you don't supply required parameters, and it clears previously set data if you don't supply optional parameters.
It's much safer to use patch for this reason. You only supply data for the fields you want to change; fields that you omit are not cleared. The only exception to this rule occurs with repeating elements or arrays: If you omit all of them, they stay just as they are; if you provide any of them, the whole set is replaced with the set that you provide.



The Gmail API returns two levels of error information:

HTTP error codes and messages in the header.
A JSON object in the response body with additional details that can help you
determine how to handle the error.

Gmail apps should catch and handle all errors that might be encountered when
using the REST API.  This guide provides instructions on how to resolve specific
API errors.
Resolve a 400 error: Bad request
This error might result from these errors your
code:

A required field or parameter hasn't been provided.
The value supplied or a combination of provided fields is invalid.
Invalid attachment.

Note: This list is not exhaustive, other cases can cause a 400 error.
Following is a sample JSON representation of this error:
{
  "error": {
    "code": 400,
    "errors": [
      {
        "domain": "global",
        "location": "orderBy",
        "locationType": "parameter",
        "message": "Sorting is not supported for queries with fullText terms. Results are always in descending relevance order.",
        "reason": "badRequest"
      }
    ],
    "message": "Sorting is not supported for queries with fullText terms. Results are always in descending relevance order."
  }
}

To fix this error, check the message field and adjust your code accordingly.
Resolve a 401 error: Invalid credentials
A 401 error indicates that the access token you're using is either expired
or invalid. This error can also be caused by missing authorization for the
requested scopes. Following is the JSON representation of this error:
{
  "error": {
    "errors": [
      {
        "domain": "global",
        "reason": "authError",
        "message": "Invalid Credentials",
        "locationType": "header",
        "location": "Authorization",
      }
    ],
    "code": 401,
    "message": "Invalid Credentials"
  }
}

To fix this error, refresh the access token using the long-lived refresh
token.  If you are using a client library, it automatically handles token
refresh. If this fails, direct the user through the OAuth flow, as described
in Authorizing your App with Gmail.
For additional information on Gmail limits, refer to
Usage limits.
Resolve a 403 error: Usage limit exceeded
An error 403 occurs when a usage limit has been exceeded or the user doesn't
have the correct privileges. To determine the specific type of error, evaluate
the reason field of the returned JSON. This error occurs for the following
situations:

The daily limit was exceeded.
The user rate limit was exceeded.
The project rate limit was exceeded.
Your app can't be used within the authenticated user's domain.

For additional information on Gmail limits, refer to
Usage limits.
Resolve a 403 error: Daily limit exceeded
A dailyLimitExceeded error indicates that the courtesy API limit for your
project has been reached. Following is the JSON representation of this error:
{
  "error": {
    "errors": [
      {
        "domain": "usageLimits",
        "reason": "dailyLimitExceeded",
        "message": "Daily Limit Exceeded"
      }
    ],
    "code": 403,
    "message": "Daily Limit Exceeded"
  }
}

To fix this error:

Visit the Google API Console
Select your project.
Click the Quotas tab
Request additional quota. For more information, see
Request additional quota.

For additional information on Gmail limits, refer to
Usage limits.
Resolve a 403 error: User rate limit exceeded
A userRateLimitExceeded error indicates that the per-user limit has been
reached. Following is the
JSON representation of this error:
{
 "error": {
  "errors": [
   {
    "domain": "usageLimits",
    "reason": "userRateLimitExceeded",
    "message": "User Rate Limit Exceeded"
   }
  ],
  "code": 403,
  "message": "User Rate Limit Exceeded"
 }
}

To fix this error, try to optimize
your application code to make fewer requests or retry requests. For information
on retrying requests, refer to
Retry failed requests to resolve errors.
For additional information on Gmail limits, refer to
Usage limits.
Resolve a 403 error: Rate limit exceeded
A rateLimitExceeded error indicates that the user has reached Gmail API's
maximum request rate. This limit varies depending on the type of requests.
Following is the JSON representation of this error:
{
 "error": {
  "errors": [
   {
    "domain": "usageLimits",
    "message": "Rate Limit Exceeded",
    "reason": "rateLimitExceeded",
   }
  ],
  "code": 403,
  "message": "Rate Limit Exceeded"
 }
}

To fix this error, retry failed requests.
For additional information on Gmail limits, refer to
Usage limits.
Resolve a 403 error: App with id {appId} cannot be used within the authenticated user's domain
A domainPolicy error occurs when the policy for the user's domain doesn't
allow access to Gmail by your app. Following is the JSON representation
of this error:
{
  "error": {
    "errors": [
      {
        "domain": "global",
        "reason": "domainPolicy",
        "message": "The domain administrators have disabled Gmail apps."
      }
    ],
    "code": 403,
    "message": "The domain administrators have disabled Gmail apps."
  }
}

To fix this error:

Inform the user that the domain doesn't allow your app to access Gmail.
Instruct the user to contact the domain Admin to request access for your app.

Resolve a 429 error: Too many requests
A 429 "Too many requests" error can occur due to daily per-user limits
(including mail sending limits), bandwidth limits, or a per-user concurrent
request limit. Information about each limit follows. However, each limit can be
resolved either by trying to retry failed requests or by
splitting processing across multiple Gmail accounts. Per-user limits
cannot be increased for any reason. For more information about limits, see
Usage limits.
Mail sending limits
The Gmail API enforces the standard daily mail sending limits. These limits
differ for paying Google Workspace users and trial
gmail.com users. For these limits, refer to
Gmail sending limits in Google Workspace.
These limits are per-user and are shared by all of the user's clients, whether
API clients, native/web clients or SMTP MSA.  If these limits are
exceeded, a HTTP 429 Too Many Requests "User-rate limit exceeded"
"(Mail sending)" error is returned with time to retry.
Note that daily limits being exceeded may result in these types of errors for
multiple hours before the request is accepted.
The mail sending pipeline is complex: once the user exceeds their quota,
there can be a delay of several minutes before the API begins to return 429
error responses. So you cannot assume that a 200 response means the email was
successfully sent.
Bandwidth limits
The API has per-user upload and download
bandwidth limits that are
equal to, but independent of, IMAP.  These limits are shared across all Gmail API
clients for a given user.
These limits are typically only hit in exceptional or abusive situations.
If these limits are exceeded a HTTP 429 Too Many Requests
"User-rate limit exceeded" error is returned with a time to retry.
Note that daily limits being exceeded may result in these types of errors
for multiple hours before the request is accepted.
Concurrent Requests
The Gmail API enforces a per-user concurrent request limit (in addition
to the per-user rate limit).  This limit is shared by all Gmail API
clients accessing a given user and ensures that no API client is overloading
a Gmail user mailbox or their backend server.
Making many parallel requests for a single user or sending batches with a
large number of requests can trigger this error. A large number of
independent API clients accessing the Gmail user mailbox simultaneously can also
trigger this error.  If this limit is exceeded a HTTP 429 Too Many Requests
"Too many concurrent requests for user" error is returned.  
Resolve a 500 error: Backend error
A backendError occurs when an unexpected error arises while processing the
request.
{
 "error": {
  "errors": [
   {
    "domain": "global",
    "reason": "backendError",
    "message": "Backend Error",
   }
  ],
  "code": 500,
  "message": "Backend Error"
 }
}

To fix this error, retry failed requests. Following is a
list of 500 errors:

502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout

Retry failed requests to resolve errors
You can periodically retry a failed request over an increasing amount of time to
handle errors related to rate limits, network volume, or response time. For
example, you might retry a failed request after one second, then after two
seconds, and then after four seconds. This method is called
exponential backoff and it is used to improve bandwidth usage and maximize
throughput of requests in concurrent environments.
Start retry periods at least one second after the error.
View or change usage limits, increase quota
To view or change usage limits for your project, or to request an increase to
your quota, do the following:

If you don't already have a billing account
    for your project, then create one.
Visit the Enabled APIs page of the
    API library in the API Console, and select an API from the
    list.
To view and change quota-related settings, select Quotas. To view
    usage statistics, select Usage.

Batch requests
Using batching is encouraged, however, larger batch sizes are likely to trigger
rate limiting. Sending batches larger than 50 requests is not recommended. For
information on how to batch requests, refer to
Batching requests.


This page describes some common issues that you might encounter involving
authentication and authorization.
This app isn't verified
If the OAuth consent screen displays the warning "This app isn't verified," your
app is requesting scopes that provide access to sensitive user data. If your
application uses sensitive scopes, your app must go through the
verification process 
to remove that warning and other limitations. During the development phase, you
can continue past this warning by selecting Advanced > Go to {Project Name}
(unsafe).
File not found error for credentials.json
When running the code sample, you might receive a "file not found" or "no such
file" error message regarding credentials.json.
This error occurs when you have not authorized the desktop application
credentials. To learn how to create credentials
for a desktop application, go to
Create credentials.
After you create the credentials, make sure the downloaded JSON file is saved as
credentials.json. Then move the file to your working directory.
Token has been expired or revoked
When running the code sample, you might receive a "Token has been expired" or
"Token has been revoked" error message.
This error occurs when an access token from the Google Authorization Server has
either expired or has been revoked. For information about potential causes
and fixes, see
Refresh token expiration. 
JavaScript errors
The following are some common JavaScript errors.
Error: origin_mismatch
This error occurs during the authorization flow if the host and port used
to serve the web page doesn't match an allowed JavaScript origin on your
Google Cloud console project. Make sure you set an authorized
JavaScript origin and that the URL in your browser matches the origin URL.
idpiframe_initialization_failed: Failed to read the 'localStorage' property from 'Window'
This error occurs when third-party cookies and data storage aren't enabled
in your browser. These options are required by the Google Sign-in library. For
more information, see
3rd-party cookies and data storage.
Note: In your own app, you should prompt users to enable third-party cookies and
data storage or add an exception for accounts.google.com.
idpiframe_initialization_failed: Not a valid origin for the client
This error occurs when the domain registered doesn't match the domain being
used to host the web page. Ensure that the origin you registered matches the URL
in the browser.


This document covers the key differences between the
Email Settings API and the Gmail API. You can
use this guide to help migrate your app to the Gmail API.
Authorizing requests
Like the Email Settings API, the Gmail API uses the OAuth 2.0 protocol to
authorize requests. One key difference is that Gmail API permissions are
scoped to an individual user, rather than to the entire domain. This means
authorizing a domain administrator account does not allow you to migrate mail
for other users in the domain. Instead, you must use
standard service accounts with domain-wide authority
that are whitelisted in the Admin console to
generate the appropriate authentication token.
The Email Settings API used the scope:
https://apps-apis.google.com/a/feeds/emailsettings/2.0/

The equivalent scopes in the Gmail API are:
https://www.googleapis.com/auth/gmail.settings.basic
https://www.googleapis.com/auth/gmail.settings.sharing

Protocol changes
The Email Settings API uses the XML based GDATA protocol. The Gmail API uses
JSON. Since settings are mostly comprised of key/value pairs, payloads are
conceptually similar between versions.
Example of creating a label:

Email Settings APIPOST https://apps-apis.google.com/a/feeds/emailsettings/2.0/{domain name}/{username}/label
<?xml version="1.0" encoding="utf-8"?>
<atom:entry xmlns:atom="http://www.w3.org/2005/Atom" xmlns:apps="http://schemas.google.com/apps/2006">
  <apps:property name="label" value="status updates" />
</atom:entry>

Gmail APIPOST https://www.googleapis.com/gmail/v1/users/{username}/labels
{
   "name": "status updates"
}


Use the provided Client libraries instead of directly
implementing the protocol.
Managing labels
To manage labels in the Gmail API, use the
Labels resource.



Old setting
New setting
Notes




labelId
id



label
name



unreadCount
messagesUnread



visibility
labelListVisibility
SHOW is now labelShowHIDE is now labelHide



Other changes:

When updating or deleting labels, the Gmail API references labels by ID
instead of by name.

Managing filters
To manage filters in the Gmail API, use the
Filters resource.



Old setting
New setting
Notes




from
criteria.from



to
criteria.to



subject
criteria.subject



hasTheWord
criteria.query



doesNotHaveTheWord
criteria.negatedQuery



hasAttachment
criteria.hasAttachment



shouldArchive
action.removeLabelIds
Use INBOX as the label ID


shouldMarkAsRead
action.removeLabelIds
Use UNREAD as the label ID


shouldStar
action.addLabelIds
Use STARRED as the label ID


label
action.addLabelIds
Use the ID of the label to add


forwardTo
action.forward



shouldTrash
action.addLabelIds
Use TRASH as the label ID


neverSpam
action.removeLabelIds
Use SPAM as the label ID



Other changes:

If adding a user label does not already exist, it must be explicitly created using
the labels.create method.

Managing send-as aliases
To manage send-as aliases in the Gmail API, use the
SendAs resource.



Old setting
New setting




name
displayName


address
sendAsEmail


replyTo
replyToAddress


makeDefault
isDefault



Managing web clips
Web Clip settings are no longer available via the API.
Managing auto-forwarding settings
To manage auto-forwarding in the Gmail API, use the
Settings resource.



Old setting
New setting
Notes




enable
enabled



forwardTo
emailAddress



action
disposition
KEEP is now leaveInInboxARCHIVE is now archiveDELETE is now trashMARK_READ is now markRead



Other changes:

Forwarding addresses must be created and verified prior to use
Forwarding addresses can be managed via the ForwardingAddresses
resource.

Managing POP settings
To manage POP access in the Gmail API, use the
Settings resource.



Old setting
New setting
Notes




enable
accessWindow
Disabled when set to disabled


enableFor
accessWindow
ALL_MAIL is now allMailMAIL_FROM_NOW_ON is now fromNowOn


action
disposition
KEEP is now leaveInInboxARCHIVE is now archiveDELETE is now trashMARK_READ is now markRead



Managing IMAP settings
To manage IMAP access in the Gmail API, use the
Settings resource.



Old setting
New setting




enable
enabled



Managing vacation auto-reply settings
To manage vacation auto-reply in the Gmail API, use the
Settings resource.



Old setting
New setting




contactsOnly
restrictToContacts


domainOnly
restrictToDomain


enable
enableAutoReply


endDate
endTime


message
responseBodyHtmlresponseBodyPlainText


startDate
startTime


subject
responseSubject



Managing signature settings
To manage email signatures in the Gmail API, use the
SendAs resource.



Old setting
New setting




signature
signature



Other changes:

Signatures are now managed per alias.

Managing language settings
To manage language settings in the Gmail API, use the
Settings resource.



Old setting
New setting




language
displayLanguage



Please refer to the
Managing Language Settings guide for more
information.
Managing delegation settings
To manage delegation in the Gmail API, use the
Delegates resource.



Old setting
New setting




address
delegateEmail


status
verificationStatus



Other changes:

General

To use any of the delegation methods
(including delegates.create)
the delegator user must be enabled for Gmail. That means, for example, that
the delegator user cannot be suspended in
Google Workspace.
An email alias cannot be used as the delegate email input for any of the new
methods. A delegate user must be referred to by their primary email address.

delegates.create

This method can now be used to create delegate relationships across multiple
domains belonging to the same Google Workspace
organization.
This method can now be used for users which require a password change at
their next sign in.
If successful, this method returns a
Users.settings.delegates resource
in the response body, rather than an empty response body.
If either of the delegator or delegate users are disabled (for example,
suspended in Google Workspace) this method fails
with an HTTP 4XX error instead of an HTTP 500 error.

delegates.delete

This method can now be used to delete delegates with any
verificationStatus,
rather than just delegates which are accepted or expired.

delegates.get

This is a new method, which might be preferable over the
delegates.list
method depending on need.


Managing general settings
General settings are no longer available via the API.

